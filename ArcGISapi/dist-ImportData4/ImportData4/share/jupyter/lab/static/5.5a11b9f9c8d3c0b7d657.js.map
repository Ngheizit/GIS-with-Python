{"version":3,"sources":["webpack:///./node_modules/codemirror/keymap/vim.js"],"names":["mod","__webpack_require__","CodeMirror","defaultKeymap","keys","type","toKeys","context","action","motion","motionArgs","linewise","toJumplist","forward","wordEnd","bigWord","inclusive","explicitRepeat","toFirstChar","repeatOffset","isEdit","actionArgs","after","matchIndent","sameLine","operator","operatorArgs","indentRight","toLower","operatorMotionArgs","visualLine","shouldMoveCursor","insertAt","interlaceInsertRepeat","blockwise","replace","position","increase","backtrack","textObjectInner","searchArgs","querySrc","wholeWordOnly","defaultKeymapLength","length","defaultExCommandMap","name","shortName","possiblyAsync","excludeFromCommandHistory","Pos","Vim","enterVimMode","cm","setOption","signal","mode","on","onCursorActivity","maybeInitVimState","getInputField","getOnPasteFn","leaveVimMode","off","state","vim","detachVimMap","next","this","keyMap","rmClass","getWrapperElement","getOption","document","body","style","caretColor","disableFatCursorMark","attach","attachVimMap","prev","addClass","enableFatCursorMark","updateFatCursorMark","fatCursorMarks","clearFatCursorMark","ranges","listSelections","result","i","range","empty","anchor","ch","getLine","line","push","markText","className","widget","createElement","textContent","setBookmark","marks","clear","defineOption","val","Init","test","cmKey","key","undefined","vimKey","cmKeyToVimKey","cmd","findKey","modifiers","Shift","Ctrl","Alt","Cmd","Mod","specialKeys","Enter","Backspace","Delete","Insert","charAt","pieces","split","lastPiece","hasCharacter","piece","isUpperCase","toLowerCase","join","onPasteFn","insertMode","setCursor","offsetCursor","getCursor","actions","enterInsertMode","numberRegex","wordCharTest","isWordChar","bigWordCharTest","makeKeyRange","start","size","String","fromCharCode","upperCaseAlphabet","lowerCaseAlphabet","numbers","validMarks","concat","validRegisters","isLine","firstLine","lastLine","isLowerCase","k","isMatchableSymbol","indexOf","isNumber","isWhiteSpaceString","isEndOfSentenceSymbol","inArray","arr","options","defaultValue","aliases","callback","Error","value","cfg","option","scope","local","createCircularJumpList","pointer","head","tail","buffer","Array","add","oldCur","newCur","current","curMark","useNextSlot","cursor","trashMark","markPos","find","cursorEqual","move","offset","mark","inc","cachedCursor","createInsertModeChanges","c","changes","expectCursorActivityForChange","MacroModeState","latestRegister","isPlaying","isRecording","replaySearchQueries","onRecordingDone","lastInsertModeChanges","prototype","exitMacroRecordMode","macroModeState","vimGlobalState","enterMacroRecordMode","registerName","register","registerController","getRegister","openDialog","bottom","inputState","InputState","lastEditInputState","lastEditActionCommand","lastHPos","lastHSPos","lastMotion","fakeCursor","insertModeRepeat","visualMode","visualBlock","lastSelection","lastPastedText","sel","resetVimGlobalState","searchQuery","searchIsReversed","lastSubstituteReplacePart","jumpList","lastCharacterSearch","increment","selectedCharacter","RegisterController","searchHistoryController","HistoryController","exCommandHistoryController","optionName","lastInsertModeKeyTimer","vimApi","buildKeyMap","getRegisterController","resetVimGlobalState_","getVimGlobalState_","maybeInitVimState_","suppressErrorLogging","InsertModeKey","map","lhs","rhs","ctx","exCommandDispatcher","unmap","noremap","toCtxArray","ctxsToMap","actualLength","origLength","mapping","substr","newMapping","_mapCommand","mappedCtxs","filter","el","mapclear","userKeymap","slice","contexts","j","defineEx","prefix","func","exCommands","commandMap_","handleKey","origin","command","handleMacroRecording","clearInputState","logKey","handleEsc","exitVisualMode","exitInsertMode","doKeyToKey","match","exec","substring","index","handleKeyInsertMode","keyBuffer","keysAreChars","commandDispatcher","matchCommand","thisMatch","window","clearTimeout","setTimeout","selections","here","replaceRange","pop","handleKeyNonInsertMode","keysMatcher","pushRepeatDigit","operation","curOp","isVimOp","processCommand","e","console","handleEx","input","defineMotion","defineAction","defineOperator","mapCommand","defineRegister","prefixRepeat","motionRepeat","n","getRepeat","repeat","parseInt","reason","Register","text","insertModeChanges","searchQueries","setText","pushText","pushInsertModeChanges","pushSearchQuery","query","toString","registers","unnamedRegister","isValidRegister","shiftNumericRegisters_","append","historyBuffer","iterator","initialPrefix","nextMatch","up","dir","element","pushInput","splice","reset","matches","commandMatches","full","partial","bestMatch","character","lastChar","repeatOverride","processMotion","processOperator","processOperatorMotion","processAction","processSearch","processEx","copyArgs","evalInput","repeatIsExplicit","recordLastEdit","getSearchCursor","getSearchState","setReversed","promptPrefix","originalQuery","getQuery","originalScrollPos","getScrollInfo","handleQuery","ignoreCase","smartCase","updateSearchQuery","showConfirm","onPromptClose","scrollTo","left","top","logSearchQuery","onPromptKeyUp","close","keyName","target","selectionEnd","selectionStart","Math","min","parsedQuery","scrollIntoView","findNext","clearSearchHighlight","onPromptKeyDown","e_stop","focus","shift","showPrompt","onClose","desc","searchPromptDesc","onKeyUp","onKeyDown","word","expandWordUnderCursor","isKeyword","end","escapeRegex","exArgs","selectValueOnOpen","origHead","copyCursor","clipCursorToContent","origAnchor","oldHead","oldAnchor","newHead","newAnchor","noRepeat","motionResult","motions","recordJumpPosition","Infinity","updateCmSelection","updateMark","cursorIsBefore","lastSel","lineOffset","abs","chOffset","curStart","curEnd","cmSel","cursorMin","cursorMax","makeCmSelection","lineLength","tmp","expandSelectionToLine","clipToLine","exclusive","setSelections","primary","operatorMoveTo","operators","actionCommand","moveToTopLine","_head","getUserVisibleLines","findFirstNonWhiteSpaceCharacter","moveToMiddleLine","floor","moveToBottomLine","expandToLine","_cm","cur","isReversed","highlightSearchMatches","goToMark","pos","getMarkPos","moveToOtherHighlightedEnd","jumpToMark","best","isWrongDirection","equal","between","cursorIsBetween","moveByCharacters","moveByLines","endCh","moveByDisplayLines","moveByScroll","moveToColumn","moveToEol","first","last","moveToStartOfLine","charCoords","res","findPosV","hitSide","lastCharCoords","goalCoords","coordsChar","resCoords","moveByPage","moveByParagraph","findParagraph","moveBySentence","findSentence","scrollbox","clientHeight","defaultTextHeight","orig","dest","moveByWords","moveToWord","moveTillCharacter","moveToCharacter","recordLastCharacterSearch","moveToSymbol","findSymbol","keepHPos","retval","clipPos","moveToFirstNonWhiteSpaceCharacter","moveToMatchedSymbol","lineText","symbol","getTokenTypeAt","re","matched","findMatchingBracket","bracketRegex","to","moveToLineOrEdgeOfDocument","lineNum","textObjectManipulation","mirroredPairs","(",")","{","}","[","]","<",">","selfPaired","'","\"","`","selectCompanionObject","findBeginningAndEnd","expandSelection","repeatLastCharacterSearch","lastSearch","moveH","fn","fillArray","times","change","args","finalHead","getRange","lastState","prevLineEnd","Number","MAX_VALUE","wasLastLine","commands","newlineAndIndent","getSelection","replacement","replaceSelections","delete","includeLineBreak","indent","startLine","endLine","indentLine","indentAuto","_args","execCommand","changeCase","getSelections","swapped","toSwap","toUpperCase","yank","endPos","jumpListWalk","scroll","lineHeight","delta","newPos","cursorCoords","ceil","newBottom","scrollToCursor","height","y","replayMacro","executeMacroRegister","toggleOverwrite","overwrite","max","onChange","onKeyEventTargetKeyDown","selectForInsert","toggleVisualMode","subMode","reselectLastSelection","_actionArgs","updateLastSelection","anchorMark","headMark","joinLines","finalCh","curFinalPos","newLineAndEnterInsertMode","newlineFn","newlineAndIndentContinueComment","paste","tabSize","whitespaceLength","str","tabs","spaces","currentLine","chompedText","wasChomped","firstIndent","wspace","newIndent","quotient","curPosFinal","idx","lastSelectionCurEnd","selectedArea","getSelectedAreaRange","selectedText","emptyStrings","selectBlock","posFromIndex","indexFromPos","lastCh","extendLineToColumn","undo","repeatFn","redo","setRegister","setMark","markName","replaceWith","replaceTo","replaceWithStr","incrementNumberToken","lineStr","numberStr","baseStr","digits","base","0b","0","","0x","number","zeroPadding","from","repeatLastEdit","maxCh","ret","prop","hasOwnProperty","offsetLine","offsetCh","commandMatch","pressed","mapped","prefixLen","pressedPrefix","mappedPrefix","cur1","cur2","arguments","apply","call","cur3","cur1before2","cur2before3","trim","s","column","isClipped","curHead","primIndex","getIndex","wasClipped","baseCh","headCh","newDir","lineHead","atAnchor","atHead","getCurrentSelectedAreaRange","getLastSelectedAreaRange","block","width","setSelection","updateFakeCursor","headOffset","anchorOffset","right","getHead","moveHead","selection","lines","firstNonWS","search","_forward","noSymbol","wordStart","symbolToMode","*","/","m","M","#","findSymbolModes","bracket","isComplete","nextCh","symb","depth","reverseSymb","section","init","curMoveThrough","comment","found","method","preprocess","token","lineCount","curCh","lineLen","findWord","emptyLineIsWord","charTests","stop","foundWord","words","eodCh","shortCircuit","firstWord","lastWord","charIdxInLine","includeChar","lastIndexOf","isEmpty","isBoundary","any","startState","nextChar","ln","curr","last_valid","skip_empty_lines","reverse","curr_index","bracketRegexp","openSym","curChar","scanForBracket","chars","len","firstIndex","SearchState","setQuery","getOverlay","searchOverlay","setOverlay","overlay","reversed","getScrollbarAnnotate","annotate","setScrollbarAnnotate","searchState_","dialog","template","shortText","prompt","splitBySlash","argString","splitBySeparator","findUnescapedSlashes","findUnescapedSeparators","separator","slashes","tokens","escapeNextChar","translateRegex","specials","unescape","out","specialComesNext","charUnescapes","\\n","\\r","\\t","translateRegexReplace","unescapes","\\/","\\\\","unescapeRegexReplace","stream","StringStream","output","eol","peek","matcher","parseQuery","lastSearchRegister","RegExp","regexPart","forceIgnoreCase","flagsPart","regexp","openNotification","duration","alert","makePrompt","raw","regexEqual","r1","r2","props","rawQuery","source","matchSol","sol","skipToEnd","backUp","searchState","removeOverlay","addOverlay","showMatchesOnScrollbar","isInRange","scrollInfo","occludeToleranceTop","occludeToleranceBottom","bottomY","history","doc","done","event","lastModTime","changeHistory","lastEditPos","ExCommandDispatcher","buildCommandMap_","opt_params","that","_processCommand","commandHistoryRegister","previousCommand","inputStream","params","parseInput_","commandName","matchCommand_","parseCommandArgs_","toInput","eatWhile","eat","lineEnd","parseLineSpec_","numberMatch","parseLineSpecOffset_","offsetMatch","delim","argDelimiter","user","unshift","colorscheme","mapArgs","imap","nmap","vmap","set","setArgs","setCfg","expr","forceGet","optionIsBoolean","oldValue","message","setOptionReturn","setlocal","setglobal","regArgs","regInfo","sort","unique","pattern","parseArgs","eatSpace","opts","decimal","hex","octal","err","lineStart","radix","numPart","textPart","matchPart","compareFn","a","b","anum","bnum","comparePatternFn","textOld","global","matchedLines","content","nextCommand","substitute","replacePart","trailing","count","confirm","startPos","doReplace","write","save","nohlsearch","delmarks","sym","startMark","finishMark","charCodeAt","finish","searchCursor","exMode","lastPos","replaceAll","newText","_value","savedCallback","detach","insertModeChangeRegister","lastChange","logInsertModeChange","extra","fallthrough","imc","repeatInsertModeChanges","changeObj","ignoreCount","selectionCount","maybeReset","handleExternalSelection","somethingSelected","onKeyFound","lookupKey","repeatForInsert","isAction","cachedInputState","repeatCommand","repeatInsert","changeObject","keyHandler","binding"],"mappings":"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","file":"5.5a11b9f9c8d3c0b7d657.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n/**\n * Supported keybindings:\n *   Too many to list. Refer to defaultKeymap below.\n *\n * Supported Ex commands:\n *   Refer to defaultExCommandMap below.\n *\n * Registers: unnamed, -, a-z, A-Z, 0-9\n *   (Does not respect the special case for number registers when delete\n *    operator is made with these commands: %, (, ),  , /, ?, n, N, {, } )\n *   TODO: Implement the remaining registers.\n *\n * Marks: a-z, A-Z, and 0-9\n *   TODO: Implement the remaining special marks. They have more complex\n *       behavior.\n *\n * Events:\n *  'vim-mode-change' - raised on the editor anytime the current mode changes,\n *                      Event object: {mode: \"visual\", subMode: \"linewise\"}\n *\n * Code structure:\n *  1. Default keymap\n *  2. Variable declarations and short basic helpers\n *  3. Instance (External API) implementation\n *  4. Internal state tracking objects (input state, counter) implementation\n *     and instantiation\n *  5. Key handler (the main command dispatcher) implementation\n *  6. Motion, operator, and action implementations\n *  7. Helper functions for the key handler, motions, operators, and actions\n *  8. Set up Vim to work as a keymap for CodeMirror.\n *  9. Ex command implementations.\n */\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../lib/codemirror\"), require(\"../addon/search/searchcursor\"), require(\"../addon/dialog/dialog\"), require(\"../addon/edit/matchbrackets.js\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\", \"../addon/search/searchcursor\", \"../addon/dialog/dialog\", \"../addon/edit/matchbrackets\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  'use strict';\n\n  var defaultKeymap = [\n    // Key to key mapping. This goes first to make it possible to override\n    // existing mappings.\n    { keys: '<Left>', type: 'keyToKey', toKeys: 'h' },\n    { keys: '<Right>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<Up>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<Down>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<Space>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<BS>', type: 'keyToKey', toKeys: 'h', context: 'normal'},\n    { keys: '<Del>', type: 'keyToKey', toKeys: 'x', context: 'normal'},\n    { keys: '<C-Space>', type: 'keyToKey', toKeys: 'W' },\n    { keys: '<C-BS>', type: 'keyToKey', toKeys: 'B', context: 'normal' },\n    { keys: '<S-Space>', type: 'keyToKey', toKeys: 'w' },\n    { keys: '<S-BS>', type: 'keyToKey', toKeys: 'b', context: 'normal' },\n    { keys: '<C-n>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<C-p>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: 's', type: 'keyToKey', toKeys: 'cl', context: 'normal' },\n    { keys: 's', type: 'keyToKey', toKeys: 'c', context: 'visual'},\n    { keys: 'S', type: 'keyToKey', toKeys: 'cc', context: 'normal' },\n    { keys: 'S', type: 'keyToKey', toKeys: 'VdO', context: 'visual' },\n    { keys: '<Home>', type: 'keyToKey', toKeys: '0' },\n    { keys: '<End>', type: 'keyToKey', toKeys: '$' },\n    { keys: '<PageUp>', type: 'keyToKey', toKeys: '<C-b>' },\n    { keys: '<PageDown>', type: 'keyToKey', toKeys: '<C-f>' },\n    { keys: '<CR>', type: 'keyToKey', toKeys: 'j^', context: 'normal' },\n    { keys: '<Ins>', type: 'action', action: 'toggleOverwrite', context: 'insert' },\n    // Motions\n    { keys: 'H', type: 'motion', motion: 'moveToTopLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'M', type: 'motion', motion: 'moveToMiddleLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'L', type: 'motion', motion: 'moveToBottomLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'h', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: false }},\n    { keys: 'l', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: true }},\n    { keys: 'j', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, linewise: true }},\n    { keys: 'k', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, linewise: true }},\n    { keys: 'gj', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: true }},\n    { keys: 'gk', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: false }},\n    { keys: 'w', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false }},\n    { keys: 'W', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false, bigWord: true }},\n    { keys: 'e', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, inclusive: true }},\n    { keys: 'E', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: 'b', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }},\n    { keys: 'B', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false, bigWord: true }},\n    { keys: 'ge', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, inclusive: true }},\n    { keys: 'gE', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: '{', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: false, toJumplist: true }},\n    { keys: '}', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: true, toJumplist: true }},\n    { keys: '(', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: false }},\n    { keys: ')', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: true }},\n    { keys: '<C-f>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: true }},\n    { keys: '<C-b>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: false }},\n    { keys: '<C-d>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: true, explicitRepeat: true }},\n    { keys: '<C-u>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: false, explicitRepeat: true }},\n    { keys: 'gg', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: 'G', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: '0', type: 'motion', motion: 'moveToStartOfLine' },\n    { keys: '^', type: 'motion', motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '+', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true }},\n    { keys: '-', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, toFirstChar:true }},\n    { keys: '_', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true, repeatOffset:-1 }},\n    { keys: '$', type: 'motion', motion: 'moveToEol', motionArgs: { inclusive: true }},\n    { keys: '%', type: 'motion', motion: 'moveToMatchedSymbol', motionArgs: { inclusive: true, toJumplist: true }},\n    { keys: 'f<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: true , inclusive: true }},\n    { keys: 'F<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: false }},\n    { keys: 't<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: true, inclusive: true }},\n    { keys: 'T<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: false }},\n    { keys: ';', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: true }},\n    { keys: ',', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: false }},\n    { keys: '\\'<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true, linewise: true}},\n    { keys: '`<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true}},\n    { keys: ']`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true } },\n    { keys: '[`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false } },\n    { keys: ']\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true, linewise: true } },\n    { keys: '[\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false, linewise: true } },\n    // the next two aren't motions but must come before more general motion declarations\n    { keys: ']p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true}},\n    { keys: '[p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true}},\n    { keys: ']<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: true, toJumplist: true}},\n    { keys: '[<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: false, toJumplist: true}},\n    { keys: '|', type: 'motion', motion: 'moveToColumn'},\n    { keys: 'o', type: 'motion', motion: 'moveToOtherHighlightedEnd', context:'visual'},\n    { keys: 'O', type: 'motion', motion: 'moveToOtherHighlightedEnd', motionArgs: {sameLine: true}, context:'visual'},\n    // Operators\n    { keys: 'd', type: 'operator', operator: 'delete' },\n    { keys: 'y', type: 'operator', operator: 'yank' },\n    { keys: 'c', type: 'operator', operator: 'change' },\n    { keys: '=', type: 'operator', operator: 'indentAuto' },\n    { keys: '>', type: 'operator', operator: 'indent', operatorArgs: { indentRight: true }},\n    { keys: '<', type: 'operator', operator: 'indent', operatorArgs: { indentRight: false }},\n    { keys: 'g~', type: 'operator', operator: 'changeCase' },\n    { keys: 'gu', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, isEdit: true },\n    { keys: 'gU', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, isEdit: true },\n    { keys: 'n', type: 'motion', motion: 'findNext', motionArgs: { forward: true, toJumplist: true }},\n    { keys: 'N', type: 'motion', motion: 'findNext', motionArgs: { forward: false, toJumplist: true }},\n    // Operator-Motion dual commands\n    { keys: 'x', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false }},\n    { keys: 'X', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true }},\n    { keys: 'D', type: 'operatorMotion', operator: 'delete', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'D', type: 'operator', operator: 'delete', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'Y', type: 'operatorMotion', operator: 'yank', motion: 'expandToLine', motionArgs: { linewise: true }, context: 'normal'},\n    { keys: 'Y', type: 'operator', operator: 'yank', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'C', type: 'operatorMotion', operator: 'change', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'C', type: 'operator', operator: 'change', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: '~', type: 'operatorMotion', operator: 'changeCase', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: 'normal'},\n    { keys: '~', type: 'operator', operator: 'changeCase', context: 'visual'},\n    { keys: '<C-w>', type: 'operatorMotion', operator: 'delete', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }, context: 'insert' },\n    //ignore C-w in normal mode\n    { keys: '<C-w>', type: 'idle', context: 'normal' },\n    // Actions\n    { keys: '<C-i>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: true }},\n    { keys: '<C-o>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: false }},\n    { keys: '<C-e>', type: 'action', action: 'scroll', actionArgs: { forward: true, linewise: true }},\n    { keys: '<C-y>', type: 'action', action: 'scroll', actionArgs: { forward: false, linewise: true }},\n    { keys: 'a', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'charAfter' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'eol' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'endOfSelectedArea' }, context: 'visual' },\n    { keys: 'i', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'inplace' }, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'firstNonBlank'}, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'startOfSelectedArea' }, context: 'visual' },\n    { keys: 'o', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: 'normal' },\n    { keys: 'O', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: 'normal' },\n    { keys: 'v', type: 'action', action: 'toggleVisualMode' },\n    { keys: 'V', type: 'action', action: 'toggleVisualMode', actionArgs: { linewise: true }},\n    { keys: '<C-v>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: '<C-q>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: 'gv', type: 'action', action: 'reselectLastSelection' },\n    { keys: 'J', type: 'action', action: 'joinLines', isEdit: true },\n    { keys: 'p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true }},\n    { keys: 'P', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true }},\n    { keys: 'r<character>', type: 'action', action: 'replace', isEdit: true },\n    { keys: '@<character>', type: 'action', action: 'replayMacro' },\n    { keys: 'q<character>', type: 'action', action: 'enterMacroRecordMode' },\n    // Handle Replace-mode as a special case of insert mode.\n    { keys: 'R', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { replace: true }},\n    { keys: 'u', type: 'action', action: 'undo', context: 'normal' },\n    { keys: 'u', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, context: 'visual', isEdit: true },\n    { keys: 'U', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, context: 'visual', isEdit: true },\n    { keys: '<C-r>', type: 'action', action: 'redo' },\n    { keys: 'm<character>', type: 'action', action: 'setMark' },\n    { keys: '\"<character>', type: 'action', action: 'setRegister' },\n    { keys: 'zz', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }},\n    { keys: 'z.', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zt', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }},\n    { keys: 'z<CR>', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'z-', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }},\n    { keys: 'zb', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '.', type: 'action', action: 'repeatLastEdit' },\n    { keys: '<C-a>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: true, backtrack: false}},\n    { keys: '<C-x>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: false, backtrack: false}},\n    { keys: '<C-t>', type: 'action', action: 'indent', actionArgs: { indentRight: true }, context: 'insert' },\n    { keys: '<C-d>', type: 'action', action: 'indent', actionArgs: { indentRight: false }, context: 'insert' },\n    // Text object motions\n    { keys: 'a<character>', type: 'motion', motion: 'textObjectManipulation' },\n    { keys: 'i<character>', type: 'motion', motion: 'textObjectManipulation', motionArgs: { textObjectInner: true }},\n    // Search\n    { keys: '/', type: 'search', searchArgs: { forward: true, querySrc: 'prompt', toJumplist: true }},\n    { keys: '?', type: 'search', searchArgs: { forward: false, querySrc: 'prompt', toJumplist: true }},\n    { keys: '*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: '#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: 'g*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', toJumplist: true }},\n    { keys: 'g#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', toJumplist: true }},\n    // Ex command\n    { keys: ':', type: 'ex' }\n  ];\n  var defaultKeymapLength = defaultKeymap.length;\n\n  /**\n   * Ex commands\n   * Care must be taken when adding to the default Ex command map. For any\n   * pair of commands that have a shared prefix, at least one of their\n   * shortNames must not match the prefix of the other command.\n   */\n  var defaultExCommandMap = [\n    { name: 'colorscheme', shortName: 'colo' },\n    { name: 'map' },\n    { name: 'imap', shortName: 'im' },\n    { name: 'nmap', shortName: 'nm' },\n    { name: 'vmap', shortName: 'vm' },\n    { name: 'unmap' },\n    { name: 'write', shortName: 'w' },\n    { name: 'undo', shortName: 'u' },\n    { name: 'redo', shortName: 'red' },\n    { name: 'set', shortName: 'se' },\n    { name: 'set', shortName: 'se' },\n    { name: 'setlocal', shortName: 'setl' },\n    { name: 'setglobal', shortName: 'setg' },\n    { name: 'sort', shortName: 'sor' },\n    { name: 'substitute', shortName: 's', possiblyAsync: true },\n    { name: 'nohlsearch', shortName: 'noh' },\n    { name: 'yank', shortName: 'y' },\n    { name: 'delmarks', shortName: 'delm' },\n    { name: 'registers', shortName: 'reg', excludeFromCommandHistory: true },\n    { name: 'global', shortName: 'g' }\n  ];\n\n  var Pos = CodeMirror.Pos;\n\n  var Vim = function() {\n    function enterVimMode(cm) {\n      cm.setOption('disableInput', true);\n      cm.setOption('showCursorWhenSelecting', false);\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      cm.on('cursorActivity', onCursorActivity);\n      maybeInitVimState(cm);\n      CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    }\n\n    function leaveVimMode(cm) {\n      cm.setOption('disableInput', false);\n      cm.off('cursorActivity', onCursorActivity);\n      CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n      cm.state.vim = null;\n    }\n\n    function detachVimMap(cm, next) {\n      if (this == CodeMirror.keyMap.vim) {\n        CodeMirror.rmClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n        if (cm.getOption(\"inputStyle\") == \"contenteditable\" && document.body.style.caretColor != null) {\n          disableFatCursorMark(cm);\n          cm.getInputField().style.caretColor = \"\";\n        }\n      }\n\n      if (!next || next.attach != attachVimMap)\n        leaveVimMode(cm);\n    }\n    function attachVimMap(cm, prev) {\n      if (this == CodeMirror.keyMap.vim) {\n        CodeMirror.addClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n        if (cm.getOption(\"inputStyle\") == \"contenteditable\" && document.body.style.caretColor != null) {\n          enableFatCursorMark(cm);\n          cm.getInputField().style.caretColor = \"transparent\";\n        }\n      }\n\n      if (!prev || prev.attach != attachVimMap)\n        enterVimMode(cm);\n    }\n\n    function updateFatCursorMark(cm) {\n      if (!cm.state.fatCursorMarks) return;\n      clearFatCursorMark(cm);\n      var ranges = cm.listSelections(), result = []\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i]\n        if (range.empty()) {\n          if (range.anchor.ch < cm.getLine(range.anchor.line).length) {\n            result.push(cm.markText(range.anchor, Pos(range.anchor.line, range.anchor.ch + 1),\n                                    {className: \"cm-fat-cursor-mark\"}))\n          } else {\n            var widget = document.createElement(\"span\")\n            widget.textContent = \"\\u00a0\"\n            widget.className = \"cm-fat-cursor-mark\"\n            result.push(cm.setBookmark(range.anchor, {widget: widget}))\n          }\n        }\n      }\n      cm.state.fatCursorMarks = result;\n    }\n\n    function clearFatCursorMark(cm) {\n      var marks = cm.state.fatCursorMarks;\n      if (marks) for (var i = 0; i < marks.length; i++) marks[i].clear();\n    }\n\n    function enableFatCursorMark(cm) {\n      cm.state.fatCursorMarks = [];\n      updateFatCursorMark(cm)\n      cm.on(\"cursorActivity\", updateFatCursorMark)\n    }\n\n    function disableFatCursorMark(cm) {\n      clearFatCursorMark(cm);\n      cm.off(\"cursorActivity\", updateFatCursorMark);\n      // explicitly set fatCursorMarks to null because event listener above\n      // can be invoke after removing it, if off is called from operation\n      cm.state.fatCursorMarks = null;\n    }\n\n    // Deprecated, simply setting the keymap works again.\n    CodeMirror.defineOption('vimMode', false, function(cm, val, prev) {\n      if (val && cm.getOption(\"keyMap\") != \"vim\")\n        cm.setOption(\"keyMap\", \"vim\");\n      else if (!val && prev != CodeMirror.Init && /^vim/.test(cm.getOption(\"keyMap\")))\n        cm.setOption(\"keyMap\", \"default\");\n    });\n\n    function cmKey(key, cm) {\n      if (!cm) { return undefined; }\n      if (this[key]) { return this[key]; }\n      var vimKey = cmKeyToVimKey(key);\n      if (!vimKey) {\n        return false;\n      }\n      var cmd = CodeMirror.Vim.findKey(cm, vimKey);\n      if (typeof cmd == 'function') {\n        CodeMirror.signal(cm, 'vim-keypress', vimKey);\n      }\n      return cmd;\n    }\n\n    var modifiers = {'Shift': 'S', 'Ctrl': 'C', 'Alt': 'A', 'Cmd': 'D', 'Mod': 'A'};\n    var specialKeys = {Enter:'CR',Backspace:'BS',Delete:'Del',Insert:'Ins'};\n    function cmKeyToVimKey(key) {\n      if (key.charAt(0) == '\\'') {\n        // Keypress character binding of format \"'a'\"\n        return key.charAt(1);\n      }\n      var pieces = key.split(/-(?!$)/);\n      var lastPiece = pieces[pieces.length - 1];\n      if (pieces.length == 1 && pieces[0].length == 1) {\n        // No-modifier bindings use literal character bindings above. Skip.\n        return false;\n      } else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {\n        // Ignore Shift+char bindings as they should be handled by literal character.\n        return false;\n      }\n      var hasCharacter = false;\n      for (var i = 0; i < pieces.length; i++) {\n        var piece = pieces[i];\n        if (piece in modifiers) { pieces[i] = modifiers[piece]; }\n        else { hasCharacter = true; }\n        if (piece in specialKeys) { pieces[i] = specialKeys[piece]; }\n      }\n      if (!hasCharacter) {\n        // Vim does not support modifier only keys.\n        return false;\n      }\n      // TODO: Current bindings expect the character to be lower case, but\n      // it looks like vim key notation uses upper case.\n      if (isUpperCase(lastPiece)) {\n        pieces[pieces.length - 1] = lastPiece.toLowerCase();\n      }\n      return '<' + pieces.join('-') + '>';\n    }\n\n    function getOnPasteFn(cm) {\n      var vim = cm.state.vim;\n      if (!vim.onPasteFn) {\n        vim.onPasteFn = function() {\n          if (!vim.insertMode) {\n            cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n            actions.enterInsertMode(cm, {}, vim);\n          }\n        };\n      }\n      return vim.onPasteFn;\n    }\n\n    var numberRegex = /[\\d]/;\n    var wordCharTest = [CodeMirror.isWordChar, function(ch) {\n      return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n    }], bigWordCharTest = [function(ch) {\n      return /\\S/.test(ch);\n    }];\n    function makeKeyRange(start, size) {\n      var keys = [];\n      for (var i = start; i < start + size; i++) {\n        keys.push(String.fromCharCode(i));\n      }\n      return keys;\n    }\n    var upperCaseAlphabet = makeKeyRange(65, 26);\n    var lowerCaseAlphabet = makeKeyRange(97, 26);\n    var numbers = makeKeyRange(48, 10);\n    var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);\n    var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '\"', '.', ':', '/']);\n\n    function isLine(cm, line) {\n      return line >= cm.firstLine() && line <= cm.lastLine();\n    }\n    function isLowerCase(k) {\n      return (/^[a-z]$/).test(k);\n    }\n    function isMatchableSymbol(k) {\n      return '()[]{}'.indexOf(k) != -1;\n    }\n    function isNumber(k) {\n      return numberRegex.test(k);\n    }\n    function isUpperCase(k) {\n      return (/^[A-Z]$/).test(k);\n    }\n    function isWhiteSpaceString(k) {\n      return (/^\\s*$/).test(k);\n    }\n    function isEndOfSentenceSymbol(k) {\n      return '.?!'.indexOf(k) != -1;\n    }\n    function inArray(val, arr) {\n      for (var i = 0; i < arr.length; i++) {\n        if (arr[i] == val) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    var options = {};\n    function defineOption(name, defaultValue, type, aliases, callback) {\n      if (defaultValue === undefined && !callback) {\n        throw Error('defaultValue is required unless callback is provided');\n      }\n      if (!type) { type = 'string'; }\n      options[name] = {\n        type: type,\n        defaultValue: defaultValue,\n        callback: callback\n      };\n      if (aliases) {\n        for (var i = 0; i < aliases.length; i++) {\n          options[aliases[i]] = options[name];\n        }\n      }\n      if (defaultValue) {\n        setOption(name, defaultValue);\n      }\n    }\n\n    function setOption(name, value, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.type == 'boolean') {\n        if (value && value !== true) {\n          return new Error('Invalid argument: ' + name + '=' + value);\n        } else if (value !== false) {\n          // Boolean options are set to true if value is not defined.\n          value = true;\n        }\n      }\n      if (option.callback) {\n        if (scope !== 'local') {\n          option.callback(value, undefined);\n        }\n        if (scope !== 'global' && cm) {\n          option.callback(value, cm);\n        }\n      } else {\n        if (scope !== 'local') {\n          option.value = option.type == 'boolean' ? !!value : value;\n        }\n        if (scope !== 'global' && cm) {\n          cm.state.vim.options[name] = {value: value};\n        }\n      }\n    }\n\n    function getOption(name, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.callback) {\n        var local = cm && option.callback(undefined, cm);\n        if (scope !== 'global' && local !== undefined) {\n          return local;\n        }\n        if (scope !== 'local') {\n          return option.callback();\n        }\n        return;\n      } else {\n        var local = (scope !== 'global') && (cm && cm.state.vim.options[name]);\n        return (local || (scope !== 'local') && option || {}).value;\n      }\n    }\n\n    defineOption('filetype', undefined, 'string', ['ft'], function(name, cm) {\n      // Option is local. Do nothing for global.\n      if (cm === undefined) {\n        return;\n      }\n      // The 'filetype' option proxies to the CodeMirror 'mode' option.\n      if (name === undefined) {\n        var mode = cm.getOption('mode');\n        return mode == 'null' ? '' : mode;\n      } else {\n        var mode = name == '' ? 'null' : name;\n        cm.setOption('mode', mode);\n      }\n    });\n\n    var createCircularJumpList = function() {\n      var size = 100;\n      var pointer = -1;\n      var head = 0;\n      var tail = 0;\n      var buffer = new Array(size);\n      function add(cm, oldCur, newCur) {\n        var current = pointer % size;\n        var curMark = buffer[current];\n        function useNextSlot(cursor) {\n          var next = ++pointer % size;\n          var trashMark = buffer[next];\n          if (trashMark) {\n            trashMark.clear();\n          }\n          buffer[next] = cm.setBookmark(cursor);\n        }\n        if (curMark) {\n          var markPos = curMark.find();\n          // avoid recording redundant cursor position\n          if (markPos && !cursorEqual(markPos, oldCur)) {\n            useNextSlot(oldCur);\n          }\n        } else {\n          useNextSlot(oldCur);\n        }\n        useNextSlot(newCur);\n        head = pointer;\n        tail = pointer - size + 1;\n        if (tail < 0) {\n          tail = 0;\n        }\n      }\n      function move(cm, offset) {\n        pointer += offset;\n        if (pointer > head) {\n          pointer = head;\n        } else if (pointer < tail) {\n          pointer = tail;\n        }\n        var mark = buffer[(size + pointer) % size];\n        // skip marks that are temporarily removed from text buffer\n        if (mark && !mark.find()) {\n          var inc = offset > 0 ? 1 : -1;\n          var newCur;\n          var oldCur = cm.getCursor();\n          do {\n            pointer += inc;\n            mark = buffer[(size + pointer) % size];\n            // skip marks that are the same as current position\n            if (mark &&\n                (newCur = mark.find()) &&\n                !cursorEqual(oldCur, newCur)) {\n              break;\n            }\n          } while (pointer < head && pointer > tail);\n        }\n        return mark;\n      }\n      return {\n        cachedCursor: undefined, //used for # and * jumps\n        add: add,\n        move: move\n      };\n    };\n\n    // Returns an object to track the changes associated insert mode.  It\n    // clones the object that is passed in, or creates an empty object one if\n    // none is provided.\n    var createInsertModeChanges = function(c) {\n      if (c) {\n        // Copy construction\n        return {\n          changes: c.changes,\n          expectCursorActivityForChange: c.expectCursorActivityForChange\n        };\n      }\n      return {\n        // Change list\n        changes: [],\n        // Set to true on change, false on cursorActivity.\n        expectCursorActivityForChange: false\n      };\n    };\n\n    function MacroModeState() {\n      this.latestRegister = undefined;\n      this.isPlaying = false;\n      this.isRecording = false;\n      this.replaySearchQueries = [];\n      this.onRecordingDone = undefined;\n      this.lastInsertModeChanges = createInsertModeChanges();\n    }\n    MacroModeState.prototype = {\n      exitMacroRecordMode: function() {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.onRecordingDone) {\n          macroModeState.onRecordingDone(); // close dialog\n        }\n        macroModeState.onRecordingDone = undefined;\n        macroModeState.isRecording = false;\n      },\n      enterMacroRecordMode: function(cm, registerName) {\n        var register =\n            vimGlobalState.registerController.getRegister(registerName);\n        if (register) {\n          register.clear();\n          this.latestRegister = registerName;\n          if (cm.openDialog) {\n            this.onRecordingDone = cm.openDialog(\n                '(recording)['+registerName+']', null, {bottom:true});\n          }\n          this.isRecording = true;\n        }\n      }\n    };\n\n    function maybeInitVimState(cm) {\n      if (!cm.state.vim) {\n        // Store instance state in the CodeMirror object.\n        cm.state.vim = {\n          inputState: new InputState(),\n          // Vim's input state that triggered the last edit, used to repeat\n          // motions and operators with '.'.\n          lastEditInputState: undefined,\n          // Vim's action command before the last edit, used to repeat actions\n          // with '.' and insert mode repeat.\n          lastEditActionCommand: undefined,\n          // When using jk for navigation, if you move from a longer line to a\n          // shorter line, the cursor may clip to the end of the shorter line.\n          // If j is pressed again and cursor goes to the next line, the\n          // cursor should go back to its horizontal position on the longer\n          // line if it can. This is to keep track of the horizontal position.\n          lastHPos: -1,\n          // Doing the same with screen-position for gj/gk\n          lastHSPos: -1,\n          // The last motion command run. Cleared if a non-motion command gets\n          // executed in between.\n          lastMotion: null,\n          marks: {},\n          // Mark for rendering fake cursor for visual mode.\n          fakeCursor: null,\n          insertMode: false,\n          // Repeat count for changes made in insert mode, triggered by key\n          // sequences like 3,i. Only exists when insertMode is true.\n          insertModeRepeat: undefined,\n          visualMode: false,\n          // If we are in visual line mode. No effect if visualMode is false.\n          visualLine: false,\n          visualBlock: false,\n          lastSelection: null,\n          lastPastedText: null,\n          sel: {},\n          // Buffer-local/window-local values of vim options.\n          options: {}\n        };\n      }\n      return cm.state.vim;\n    }\n    var vimGlobalState;\n    function resetVimGlobalState() {\n      vimGlobalState = {\n        // The current search query.\n        searchQuery: null,\n        // Whether we are searching backwards.\n        searchIsReversed: false,\n        // Replace part of the last substituted pattern\n        lastSubstituteReplacePart: undefined,\n        jumpList: createCircularJumpList(),\n        macroModeState: new MacroModeState,\n        // Recording latest f, t, F or T motion command.\n        lastCharacterSearch: {increment:0, forward:true, selectedCharacter:''},\n        registerController: new RegisterController({}),\n        // search history buffer\n        searchHistoryController: new HistoryController(),\n        // ex Command history buffer\n        exCommandHistoryController : new HistoryController()\n      };\n      for (var optionName in options) {\n        var option = options[optionName];\n        option.value = option.defaultValue;\n      }\n    }\n\n    var lastInsertModeKeyTimer;\n    var vimApi= {\n      buildKeyMap: function() {\n        // TODO: Convert keymap into dictionary format for fast lookup.\n      },\n      // Testing hook, though it might be useful to expose the register\n      // controller anyways.\n      getRegisterController: function() {\n        return vimGlobalState.registerController;\n      },\n      // Testing hook.\n      resetVimGlobalState_: resetVimGlobalState,\n\n      // Testing hook.\n      getVimGlobalState_: function() {\n        return vimGlobalState;\n      },\n\n      // Testing hook.\n      maybeInitVimState_: maybeInitVimState,\n\n      suppressErrorLogging: false,\n\n      InsertModeKey: InsertModeKey,\n      map: function(lhs, rhs, ctx) {\n        // Add user defined key bindings.\n        exCommandDispatcher.map(lhs, rhs, ctx);\n      },\n      unmap: function(lhs, ctx) {\n        exCommandDispatcher.unmap(lhs, ctx);\n      },\n      // Non-recursive map function.\n      // NOTE: This will not create mappings to key maps that aren't present\n      // in the default key map. See TODO at bottom of function.\n      noremap: function(lhs, rhs, ctx) {\n        function toCtxArray(ctx) {\n          return ctx ? [ctx] : ['normal', 'insert', 'visual'];\n        }\n        var ctxsToMap = toCtxArray(ctx);\n        // Look through all actual defaults to find a map candidate.\n        var actualLength = defaultKeymap.length, origLength = defaultKeymapLength;\n        for (var i = actualLength - origLength;\n             i < actualLength && ctxsToMap.length;\n             i++) {\n          var mapping = defaultKeymap[i];\n          // Omit mappings that operate in the wrong context(s) and those of invalid type.\n          if (mapping.keys == rhs &&\n              (!ctx || !mapping.context || mapping.context === ctx) &&\n              mapping.type.substr(0, 2) !== 'ex' &&\n              mapping.type.substr(0, 3) !== 'key') {\n            // Make a shallow copy of the original keymap entry.\n            var newMapping = {};\n            for (var key in mapping) {\n              newMapping[key] = mapping[key];\n            }\n            // Modify it point to the new mapping with the proper context.\n            newMapping.keys = lhs;\n            if (ctx && !newMapping.context) {\n              newMapping.context = ctx;\n            }\n            // Add it to the keymap with a higher priority than the original.\n            this._mapCommand(newMapping);\n            // Record the mapped contexts as complete.\n            var mappedCtxs = toCtxArray(mapping.context);\n            ctxsToMap = ctxsToMap.filter(function(el) { return mappedCtxs.indexOf(el) === -1; });\n          }\n        }\n        // TODO: Create non-recursive keyToKey mappings for the unmapped contexts once those exist.\n      },\n      // Remove all user-defined mappings for the provided context.\n      mapclear: function(ctx) {\n        // Partition the existing keymap into user-defined and true defaults.\n        var actualLength = defaultKeymap.length,\n            origLength = defaultKeymapLength;\n        var userKeymap = defaultKeymap.slice(0, actualLength - origLength);\n        defaultKeymap = defaultKeymap.slice(actualLength - origLength);\n        if (ctx) {\n          // If a specific context is being cleared, we need to keep mappings\n          // from all other contexts.\n          for (var i = userKeymap.length - 1; i >= 0; i--) {\n            var mapping = userKeymap[i];\n            if (ctx !== mapping.context) {\n              if (mapping.context) {\n                this._mapCommand(mapping);\n              } else {\n                // `mapping` applies to all contexts so create keymap copies\n                // for each context except the one being cleared.\n                var contexts = ['normal', 'insert', 'visual'];\n                for (var j in contexts) {\n                  if (contexts[j] !== ctx) {\n                    var newMapping = {};\n                    for (var key in mapping) {\n                      newMapping[key] = mapping[key];\n                    }\n                    newMapping.context = contexts[j];\n                    this._mapCommand(newMapping);\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace\n      // them, or somehow make them work with the existing CodeMirror setOption/getOption API.\n      setOption: setOption,\n      getOption: getOption,\n      defineOption: defineOption,\n      defineEx: function(name, prefix, func){\n        if (!prefix) {\n          prefix = name;\n        } else if (name.indexOf(prefix) !== 0) {\n          throw new Error('(Vim.defineEx) \"'+prefix+'\" is not a prefix of \"'+name+'\", command not registered');\n        }\n        exCommands[name]=func;\n        exCommandDispatcher.commandMap_[prefix]={name:name, shortName:prefix, type:'api'};\n      },\n      handleKey: function (cm, key, origin) {\n        var command = this.findKey(cm, key, origin);\n        if (typeof command === 'function') {\n          return command();\n        }\n      },\n      /**\n       * This is the outermost function called by CodeMirror, after keys have\n       * been mapped to their Vim equivalents.\n       *\n       * Finds a command based on the key (and cached keys if there is a\n       * multi-key sequence). Returns `undefined` if no key is matched, a noop\n       * function if a partial match is found (multi-key), and a function to\n       * execute the bound command if a a key is matched. The function always\n       * returns true.\n       */\n      findKey: function(cm, key, origin) {\n        var vim = maybeInitVimState(cm);\n        function handleMacroRecording() {\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            if (key == 'q') {\n              macroModeState.exitMacroRecordMode();\n              clearInputState(cm);\n              return true;\n            }\n            if (origin != 'mapping') {\n              logKey(macroModeState, key);\n            }\n          }\n        }\n        function handleEsc() {\n          if (key == '<Esc>') {\n            // Clear input state and get back to normal mode.\n            clearInputState(cm);\n            if (vim.visualMode) {\n              exitVisualMode(cm);\n            } else if (vim.insertMode) {\n              exitInsertMode(cm);\n            }\n            return true;\n          }\n        }\n        function doKeyToKey(keys) {\n          // TODO: prevent infinite recursion.\n          var match;\n          while (keys) {\n            // Pull off one command key, which is either a single character\n            // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n            match = (/<\\w+-.+?>|<\\w+>|./).exec(keys);\n            key = match[0];\n            keys = keys.substring(match.index + key.length);\n            CodeMirror.Vim.handleKey(cm, key, 'mapping');\n          }\n        }\n\n        function handleKeyInsertMode() {\n          if (handleEsc()) { return true; }\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          var keysAreChars = key.length == 1;\n          var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n          // Need to check all key substrings in insert mode.\n          while (keys.length > 1 && match.type != 'full') {\n            var keys = vim.inputState.keyBuffer = keys.slice(1);\n            var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n            if (thisMatch.type != 'none') { match = thisMatch; }\n          }\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') {\n            if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n            lastInsertModeKeyTimer = window.setTimeout(\n              function() { if (vim.insertMode && vim.inputState.keyBuffer) { clearInputState(cm); } },\n              getOption('insertModeEscKeysTimeout'));\n            return !keysAreChars;\n          }\n\n          if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n          if (keysAreChars) {\n            var selections = cm.listSelections();\n            for (var i = 0; i < selections.length; i++) {\n              var here = selections[i].head;\n              cm.replaceRange('', offsetCursor(here, 0, -(keys.length - 1)), here, '+input');\n            }\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n          }\n          clearInputState(cm);\n          return match.command;\n        }\n\n        function handleKeyNonInsertMode() {\n          if (handleMacroRecording() || handleEsc()) { return true; }\n\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          if (/^[1-9]\\d*$/.test(keys)) { return true; }\n\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (!keysMatcher) { clearInputState(cm); return false; }\n          var context = vim.visualMode ? 'visual' :\n                                         'normal';\n          var match = commandDispatcher.matchCommand(keysMatcher[2] || keysMatcher[1], defaultKeymap, vim.inputState, context);\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') { return true; }\n\n          vim.inputState.keyBuffer = '';\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (keysMatcher[1] && keysMatcher[1] != '0') {\n            vim.inputState.pushRepeatDigit(keysMatcher[1]);\n          }\n          return match.command;\n        }\n\n        var command;\n        if (vim.insertMode) { command = handleKeyInsertMode(); }\n        else { command = handleKeyNonInsertMode(); }\n        if (command === false) {\n          return !vim.insertMode && key.length === 1 ? function() { return true; } : undefined;\n        } else if (command === true) {\n          // TODO: Look into using CodeMirror's multi-key handling.\n          // Return no-op since we are caching the key. Counts as handled, but\n          // don't want act on it just yet.\n          return function() { return true; };\n        } else {\n          return function() {\n            return cm.operation(function() {\n              cm.curOp.isVimOp = true;\n              try {\n                if (command.type == 'keyToKey') {\n                  doKeyToKey(command.toKeys);\n                } else {\n                  commandDispatcher.processCommand(cm, vim, command);\n                }\n              } catch (e) {\n                // clear VIM state in case it's in a bad state.\n                cm.state.vim = undefined;\n                maybeInitVimState(cm);\n                if (!CodeMirror.Vim.suppressErrorLogging) {\n                  console['log'](e);\n                }\n                throw e;\n              }\n              return true;\n            });\n          };\n        }\n      },\n      handleEx: function(cm, input) {\n        exCommandDispatcher.processCommand(cm, input);\n      },\n\n      defineMotion: defineMotion,\n      defineAction: defineAction,\n      defineOperator: defineOperator,\n      mapCommand: mapCommand,\n      _mapCommand: _mapCommand,\n\n      defineRegister: defineRegister,\n\n      exitVisualMode: exitVisualMode,\n      exitInsertMode: exitInsertMode\n    };\n\n    // Represents the current input state.\n    function InputState() {\n      this.prefixRepeat = [];\n      this.motionRepeat = [];\n\n      this.operator = null;\n      this.operatorArgs = null;\n      this.motion = null;\n      this.motionArgs = null;\n      this.keyBuffer = []; // For matching multi-key commands.\n      this.registerName = null; // Defaults to the unnamed register.\n    }\n    InputState.prototype.pushRepeatDigit = function(n) {\n      if (!this.operator) {\n        this.prefixRepeat = this.prefixRepeat.concat(n);\n      } else {\n        this.motionRepeat = this.motionRepeat.concat(n);\n      }\n    };\n    InputState.prototype.getRepeat = function() {\n      var repeat = 0;\n      if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n        repeat = 1;\n        if (this.prefixRepeat.length > 0) {\n          repeat *= parseInt(this.prefixRepeat.join(''), 10);\n        }\n        if (this.motionRepeat.length > 0) {\n          repeat *= parseInt(this.motionRepeat.join(''), 10);\n        }\n      }\n      return repeat;\n    };\n\n    function clearInputState(cm, reason) {\n      cm.state.vim.inputState = new InputState();\n      CodeMirror.signal(cm, 'vim-command-done', reason);\n    }\n\n    /*\n     * Register stores information about copy and paste registers.  Besides\n     * text, a register must store whether it is linewise (i.e., when it is\n     * pasted, should it insert itself into a new line, or should the text be\n     * inserted at the cursor position.)\n     */\n    function Register(text, linewise, blockwise) {\n      this.clear();\n      this.keyBuffer = [text || ''];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    }\n    Register.prototype = {\n      setText: function(text, linewise, blockwise) {\n        this.keyBuffer = [text || ''];\n        this.linewise = !!linewise;\n        this.blockwise = !!blockwise;\n      },\n      pushText: function(text, linewise) {\n        // if this register has ever been set to linewise, use linewise.\n        if (linewise) {\n          if (!this.linewise) {\n            this.keyBuffer.push('\\n');\n          }\n          this.linewise = true;\n        }\n        this.keyBuffer.push(text);\n      },\n      pushInsertModeChanges: function(changes) {\n        this.insertModeChanges.push(createInsertModeChanges(changes));\n      },\n      pushSearchQuery: function(query) {\n        this.searchQueries.push(query);\n      },\n      clear: function() {\n        this.keyBuffer = [];\n        this.insertModeChanges = [];\n        this.searchQueries = [];\n        this.linewise = false;\n      },\n      toString: function() {\n        return this.keyBuffer.join('');\n      }\n    };\n\n    /**\n     * Defines an external register.\n     *\n     * The name should be a single character that will be used to reference the register.\n     * The register should support setText, pushText, clear, and toString(). See Register\n     * for a reference implementation.\n     */\n    function defineRegister(name, register) {\n      var registers = vimGlobalState.registerController.registers;\n      if (!name || name.length != 1) {\n        throw Error('Register name must be 1 character');\n      }\n      if (registers[name]) {\n        throw Error('Register already defined ' + name);\n      }\n      registers[name] = register;\n      validRegisters.push(name);\n    }\n\n    /*\n     * vim registers allow you to keep many independent copy and paste buffers.\n     * See http://usevim.com/2012/04/13/registers/ for an introduction.\n     *\n     * RegisterController keeps the state of all the registers.  An initial\n     * state may be passed in.  The unnamed register '\"' will always be\n     * overridden.\n     */\n    function RegisterController(registers) {\n      this.registers = registers;\n      this.unnamedRegister = registers['\"'] = new Register();\n      registers['.'] = new Register();\n      registers[':'] = new Register();\n      registers['/'] = new Register();\n    }\n    RegisterController.prototype = {\n      pushText: function(registerName, operator, text, linewise, blockwise) {\n        if (linewise && text.charAt(text.length - 1) !== '\\n'){\n          text += '\\n';\n        }\n        // Lowercase and uppercase registers refer to the same register.\n        // Uppercase just means append.\n        var register = this.isValidRegister(registerName) ?\n            this.getRegister(registerName) : null;\n        // if no register/an invalid register was specified, things go to the\n        // default registers\n        if (!register) {\n          switch (operator) {\n            case 'yank':\n              // The 0 register contains the text from the most recent yank.\n              this.registers['0'] = new Register(text, linewise, blockwise);\n              break;\n            case 'delete':\n            case 'change':\n              if (text.indexOf('\\n') == -1) {\n                // Delete less than 1 line. Update the small delete register.\n                this.registers['-'] = new Register(text, linewise);\n              } else {\n                // Shift down the contents of the numbered registers and put the\n                // deleted text into register 1.\n                this.shiftNumericRegisters_();\n                this.registers['1'] = new Register(text, linewise);\n              }\n              break;\n          }\n          // Make sure the unnamed register is set to what just happened\n          this.unnamedRegister.setText(text, linewise, blockwise);\n          return;\n        }\n\n        // If we've gotten to this point, we've actually specified a register\n        var append = isUpperCase(registerName);\n        if (append) {\n          register.pushText(text, linewise);\n        } else {\n          register.setText(text, linewise, blockwise);\n        }\n        // The unnamed register always has the same value as the last used\n        // register.\n        this.unnamedRegister.setText(register.toString(), linewise);\n      },\n      // Gets the register named @name.  If one of @name doesn't already exist,\n      // create it.  If @name is invalid, return the unnamedRegister.\n      getRegister: function(name) {\n        if (!this.isValidRegister(name)) {\n          return this.unnamedRegister;\n        }\n        name = name.toLowerCase();\n        if (!this.registers[name]) {\n          this.registers[name] = new Register();\n        }\n        return this.registers[name];\n      },\n      isValidRegister: function(name) {\n        return name && inArray(name, validRegisters);\n      },\n      shiftNumericRegisters_: function() {\n        for (var i = 9; i >= 2; i--) {\n          this.registers[i] = this.getRegister('' + (i - 1));\n        }\n      }\n    };\n    function HistoryController() {\n        this.historyBuffer = [];\n        this.iterator = 0;\n        this.initialPrefix = null;\n    }\n    HistoryController.prototype = {\n      // the input argument here acts a user entered prefix for a small time\n      // until we start autocompletion in which case it is the autocompleted.\n      nextMatch: function (input, up) {\n        var historyBuffer = this.historyBuffer;\n        var dir = up ? -1 : 1;\n        if (this.initialPrefix === null) this.initialPrefix = input;\n        for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i+= dir) {\n          var element = historyBuffer[i];\n          for (var j = 0; j <= element.length; j++) {\n            if (this.initialPrefix == element.substring(0, j)) {\n              this.iterator = i;\n              return element;\n            }\n          }\n        }\n        // should return the user input in case we reach the end of buffer.\n        if (i >= historyBuffer.length) {\n          this.iterator = historyBuffer.length;\n          return this.initialPrefix;\n        }\n        // return the last autocompleted query or exCommand as it is.\n        if (i < 0 ) return input;\n      },\n      pushInput: function(input) {\n        var index = this.historyBuffer.indexOf(input);\n        if (index > -1) this.historyBuffer.splice(index, 1);\n        if (input.length) this.historyBuffer.push(input);\n      },\n      reset: function() {\n        this.initialPrefix = null;\n        this.iterator = this.historyBuffer.length;\n      }\n    };\n    var commandDispatcher = {\n      matchCommand: function(keys, keyMap, inputState, context) {\n        var matches = commandMatches(keys, keyMap, context, inputState);\n        if (!matches.full && !matches.partial) {\n          return {type: 'none'};\n        } else if (!matches.full && matches.partial) {\n          return {type: 'partial'};\n        }\n\n        var bestMatch;\n        for (var i = 0; i < matches.full.length; i++) {\n          var match = matches.full[i];\n          if (!bestMatch) {\n            bestMatch = match;\n          }\n        }\n        if (bestMatch.keys.slice(-11) == '<character>') {\n          var character = lastChar(keys);\n          if (!character) return {type: 'none'};\n          inputState.selectedCharacter = character;\n        }\n        return {type: 'full', command: bestMatch};\n      },\n      processCommand: function(cm, vim, command) {\n        vim.inputState.repeatOverride = command.repeatOverride;\n        switch (command.type) {\n          case 'motion':\n            this.processMotion(cm, vim, command);\n            break;\n          case 'operator':\n            this.processOperator(cm, vim, command);\n            break;\n          case 'operatorMotion':\n            this.processOperatorMotion(cm, vim, command);\n            break;\n          case 'action':\n            this.processAction(cm, vim, command);\n            break;\n          case 'search':\n            this.processSearch(cm, vim, command);\n            break;\n          case 'ex':\n          case 'keyToEx':\n            this.processEx(cm, vim, command);\n            break;\n          default:\n            break;\n        }\n      },\n      processMotion: function(cm, vim, command) {\n        vim.inputState.motion = command.motion;\n        vim.inputState.motionArgs = copyArgs(command.motionArgs);\n        this.evalInput(cm, vim);\n      },\n      processOperator: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        if (inputState.operator) {\n          if (inputState.operator == command.operator) {\n            // Typing an operator twice like 'dd' makes the operator operate\n            // linewise\n            inputState.motion = 'expandToLine';\n            inputState.motionArgs = { linewise: true };\n            this.evalInput(cm, vim);\n            return;\n          } else {\n            // 2 different operators in a row doesn't make sense.\n            clearInputState(cm);\n          }\n        }\n        inputState.operator = command.operator;\n        inputState.operatorArgs = copyArgs(command.operatorArgs);\n        if (vim.visualMode) {\n          // Operating on a selection in visual mode. We don't need a motion.\n          this.evalInput(cm, vim);\n        }\n      },\n      processOperatorMotion: function(cm, vim, command) {\n        var visualMode = vim.visualMode;\n        var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n        if (operatorMotionArgs) {\n          // Operator motions may have special behavior in visual mode.\n          if (visualMode && operatorMotionArgs.visualLine) {\n            vim.visualLine = true;\n          }\n        }\n        this.processOperator(cm, vim, command);\n        if (!visualMode) {\n          this.processMotion(cm, vim, command);\n        }\n      },\n      processAction: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        var repeat = inputState.getRepeat();\n        var repeatIsExplicit = !!repeat;\n        var actionArgs = copyArgs(command.actionArgs) || {};\n        if (inputState.selectedCharacter) {\n          actionArgs.selectedCharacter = inputState.selectedCharacter;\n        }\n        // Actions may or may not have motions and operators. Do these first.\n        if (command.operator) {\n          this.processOperator(cm, vim, command);\n        }\n        if (command.motion) {\n          this.processMotion(cm, vim, command);\n        }\n        if (command.motion || command.operator) {\n          this.evalInput(cm, vim);\n        }\n        actionArgs.repeat = repeat || 1;\n        actionArgs.repeatIsExplicit = repeatIsExplicit;\n        actionArgs.registerName = inputState.registerName;\n        clearInputState(cm);\n        vim.lastMotion = null;\n        if (command.isEdit) {\n          this.recordLastEdit(vim, inputState, command);\n        }\n        actions[command.action](cm, actionArgs, vim);\n      },\n      processSearch: function(cm, vim, command) {\n        if (!cm.getSearchCursor) {\n          // Search depends on SearchCursor.\n          return;\n        }\n        var forward = command.searchArgs.forward;\n        var wholeWordOnly = command.searchArgs.wholeWordOnly;\n        getSearchState(cm).setReversed(!forward);\n        var promptPrefix = (forward) ? '/' : '?';\n        var originalQuery = getSearchState(cm).getQuery();\n        var originalScrollPos = cm.getScrollInfo();\n        function handleQuery(query, ignoreCase, smartCase) {\n          vimGlobalState.searchHistoryController.pushInput(query);\n          vimGlobalState.searchHistoryController.reset();\n          try {\n            updateSearchQuery(cm, query, ignoreCase, smartCase);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + query);\n            clearInputState(cm);\n            return;\n          }\n          commandDispatcher.processMotion(cm, vim, {\n            type: 'motion',\n            motion: 'findNext',\n            motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }\n          });\n        }\n        function onPromptClose(query) {\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          handleQuery(query, true /** ignoreCase */, true /** smartCase */);\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            logSearchQuery(macroModeState, query);\n          }\n        }\n        function onPromptKeyUp(e, query, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Up' || keyName == 'Down') {\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n            close(query);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.searchHistoryController.reset();\n          }\n          var parsedQuery;\n          try {\n            parsedQuery = updateSearchQuery(cm, query,\n                true /** ignoreCase */, true /** smartCase */);\n          } catch (e) {\n            // Swallow bad regexes for incremental search.\n          }\n          if (parsedQuery) {\n            cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\n          } else {\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          }\n        }\n        function onPromptKeyDown(e, query, close) {\n          var keyName = CodeMirror.keyName(e);\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && query == '')) {\n            vimGlobalState.searchHistoryController.pushInput(query);\n            vimGlobalState.searchHistoryController.reset();\n            updateSearchQuery(cm, originalQuery);\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          } else if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          }\n        }\n        switch (command.searchArgs.querySrc) {\n          case 'prompt':\n            var macroModeState = vimGlobalState.macroModeState;\n            if (macroModeState.isPlaying) {\n              var query = macroModeState.replaySearchQueries.shift();\n              handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            } else {\n              showPrompt(cm, {\n                  onClose: onPromptClose,\n                  prefix: promptPrefix,\n                  desc: searchPromptDesc,\n                  onKeyUp: onPromptKeyUp,\n                  onKeyDown: onPromptKeyDown\n              });\n            }\n            break;\n          case 'wordUnderCursor':\n            var word = expandWordUnderCursor(cm, false /** inclusive */,\n                true /** forward */, false /** bigWord */,\n                true /** noSymbol */);\n            var isKeyword = true;\n            if (!word) {\n              word = expandWordUnderCursor(cm, false /** inclusive */,\n                  true /** forward */, false /** bigWord */,\n                  false /** noSymbol */);\n              isKeyword = false;\n            }\n            if (!word) {\n              return;\n            }\n            var query = cm.getLine(word.start.line).substring(word.start.ch,\n                word.end.ch);\n            if (isKeyword && wholeWordOnly) {\n                query = '\\\\b' + query + '\\\\b';\n            } else {\n              query = escapeRegex(query);\n            }\n\n            // cachedCursor is used to save the old position of the cursor\n            // when * or # causes vim to seek for the nearest word and shift\n            // the cursor before entering the motion.\n            vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n            cm.setCursor(word.start);\n\n            handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            break;\n        }\n      },\n      processEx: function(cm, vim, command) {\n        function onPromptClose(input) {\n          // Give the prompt some time to close so that if processCommand shows\n          // an error, the elements don't overlap.\n          vimGlobalState.exCommandHistoryController.pushInput(input);\n          vimGlobalState.exCommandHistoryController.reset();\n          exCommandDispatcher.processCommand(cm, input);\n        }\n        function onPromptKeyDown(e, input, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && input == '')) {\n            vimGlobalState.exCommandHistoryController.pushInput(input);\n            vimGlobalState.exCommandHistoryController.reset();\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          }\n          if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n            close(input);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.exCommandHistoryController.reset();\n          }\n        }\n        if (command.type == 'keyToEx') {\n          // Handle user defined Ex to Ex mappings\n          exCommandDispatcher.processCommand(cm, command.exArgs.input);\n        } else {\n          if (vim.visualMode) {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':', value: '\\'<,\\'>',\n                onKeyDown: onPromptKeyDown, selectValueOnOpen: false});\n          } else {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':',\n                onKeyDown: onPromptKeyDown});\n          }\n        }\n      },\n      evalInput: function(cm, vim) {\n        // If the motion command is set, execute both the operator and motion.\n        // Otherwise return.\n        var inputState = vim.inputState;\n        var motion = inputState.motion;\n        var motionArgs = inputState.motionArgs || {};\n        var operator = inputState.operator;\n        var operatorArgs = inputState.operatorArgs || {};\n        var registerName = inputState.registerName;\n        var sel = vim.sel;\n        // TODO: Make sure cm and vim selections are identical outside visual mode.\n        var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head): cm.getCursor('head'));\n        var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n        var oldHead = copyCursor(origHead);\n        var oldAnchor = copyCursor(origAnchor);\n        var newHead, newAnchor;\n        var repeat;\n        if (operator) {\n          this.recordLastEdit(vim, inputState);\n        }\n        if (inputState.repeatOverride !== undefined) {\n          // If repeatOverride is specified, that takes precedence over the\n          // input state's repeat. Used by Ex mode and can be user defined.\n          repeat = inputState.repeatOverride;\n        } else {\n          repeat = inputState.getRepeat();\n        }\n        if (repeat > 0 && motionArgs.explicitRepeat) {\n          motionArgs.repeatIsExplicit = true;\n        } else if (motionArgs.noRepeat ||\n            (!motionArgs.explicitRepeat && repeat === 0)) {\n          repeat = 1;\n          motionArgs.repeatIsExplicit = false;\n        }\n        if (inputState.selectedCharacter) {\n          // If there is a character input, stick it in all of the arg arrays.\n          motionArgs.selectedCharacter = operatorArgs.selectedCharacter =\n              inputState.selectedCharacter;\n        }\n        motionArgs.repeat = repeat;\n        clearInputState(cm);\n        if (motion) {\n          var motionResult = motions[motion](cm, origHead, motionArgs, vim);\n          vim.lastMotion = motions[motion];\n          if (!motionResult) {\n            return;\n          }\n          if (motionArgs.toJumplist) {\n            var jumpList = vimGlobalState.jumpList;\n            // if the current motion is # or *, use cachedCursor\n            var cachedCursor = jumpList.cachedCursor;\n            if (cachedCursor) {\n              recordJumpPosition(cm, cachedCursor, motionResult);\n              delete jumpList.cachedCursor;\n            } else {\n              recordJumpPosition(cm, origHead, motionResult);\n            }\n          }\n          if (motionResult instanceof Array) {\n            newAnchor = motionResult[0];\n            newHead = motionResult[1];\n          } else {\n            newHead = motionResult;\n          }\n          // TODO: Handle null returns from motion commands better.\n          if (!newHead) {\n            newHead = copyCursor(origHead);\n          }\n          if (vim.visualMode) {\n            if (!(vim.visualBlock && newHead.ch === Infinity)) {\n              newHead = clipCursorToContent(cm, newHead, vim.visualBlock);\n            }\n            if (newAnchor) {\n              newAnchor = clipCursorToContent(cm, newAnchor, true);\n            }\n            newAnchor = newAnchor || oldAnchor;\n            sel.anchor = newAnchor;\n            sel.head = newHead;\n            updateCmSelection(cm);\n            updateMark(cm, vim, '<',\n                cursorIsBefore(newAnchor, newHead) ? newAnchor\n                    : newHead);\n            updateMark(cm, vim, '>',\n                cursorIsBefore(newAnchor, newHead) ? newHead\n                    : newAnchor);\n          } else if (!operator) {\n            newHead = clipCursorToContent(cm, newHead);\n            cm.setCursor(newHead.line, newHead.ch);\n          }\n        }\n        if (operator) {\n          if (operatorArgs.lastSel) {\n            // Replaying a visual mode operation\n            newAnchor = oldAnchor;\n            var lastSel = operatorArgs.lastSel;\n            var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n            var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n            if (lastSel.visualLine) {\n              // Linewise Visual mode: The same number of lines.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            } else if (lastSel.visualBlock) {\n              // Blockwise Visual mode: The same number of lines and columns.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n            } else if (lastSel.head.line == lastSel.anchor.line) {\n              // Normal Visual mode within one line: The same number of characters.\n              newHead = Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n            } else {\n              // Normal Visual mode with several lines: The same number of lines, in the\n              // last line the same number of characters as in the last line the last time.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            }\n            vim.visualMode = true;\n            vim.visualLine = lastSel.visualLine;\n            vim.visualBlock = lastSel.visualBlock;\n            sel = vim.sel = {\n              anchor: newAnchor,\n              head: newHead\n            };\n            updateCmSelection(cm);\n          } else if (vim.visualMode) {\n            operatorArgs.lastSel = {\n              anchor: copyCursor(sel.anchor),\n              head: copyCursor(sel.head),\n              visualBlock: vim.visualBlock,\n              visualLine: vim.visualLine\n            };\n          }\n          var curStart, curEnd, linewise, mode;\n          var cmSel;\n          if (vim.visualMode) {\n            // Init visual op\n            curStart = cursorMin(sel.head, sel.anchor);\n            curEnd = cursorMax(sel.head, sel.anchor);\n            linewise = vim.visualLine || operatorArgs.linewise;\n            mode = vim.visualBlock ? 'block' :\n                   linewise ? 'line' :\n                   'char';\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode);\n            if (linewise) {\n              var ranges = cmSel.ranges;\n              if (mode == 'block') {\n                // Linewise operators in visual block mode extend to end of line\n                for (var i = 0; i < ranges.length; i++) {\n                  ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n                }\n              } else if (mode == 'line') {\n                ranges[0].head = Pos(ranges[0].head.line + 1, 0);\n              }\n            }\n          } else {\n            // Init motion op\n            curStart = copyCursor(newAnchor || oldAnchor);\n            curEnd = copyCursor(newHead || oldHead);\n            if (cursorIsBefore(curEnd, curStart)) {\n              var tmp = curStart;\n              curStart = curEnd;\n              curEnd = tmp;\n            }\n            linewise = motionArgs.linewise || operatorArgs.linewise;\n            if (linewise) {\n              // Expand selection to entire line.\n              expandSelectionToLine(cm, curStart, curEnd);\n            } else if (motionArgs.forward) {\n              // Clip to trailing newlines only if the motion goes forward.\n              clipToLine(cm, curStart, curEnd);\n            }\n            mode = 'char';\n            var exclusive = !motionArgs.inclusive || linewise;\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode, exclusive);\n          }\n          cm.setSelections(cmSel.ranges, cmSel.primary);\n          vim.lastMotion = null;\n          operatorArgs.repeat = repeat; // For indent in visual mode.\n          operatorArgs.registerName = registerName;\n          // Keep track of linewise as it affects how paste and change behave.\n          operatorArgs.linewise = linewise;\n          var operatorMoveTo = operators[operator](\n            cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n          if (vim.visualMode) {\n            exitVisualMode(cm, operatorMoveTo != null);\n          }\n          if (operatorMoveTo) {\n            cm.setCursor(operatorMoveTo);\n          }\n        }\n      },\n      recordLastEdit: function(vim, inputState, actionCommand) {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        vim.lastEditInputState = inputState;\n        vim.lastEditActionCommand = actionCommand;\n        macroModeState.lastInsertModeChanges.changes = [];\n        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n        macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;\n      }\n    };\n\n    /**\n     * typedef {Object{line:number,ch:number}} Cursor An object containing the\n     *     position of the cursor.\n     */\n    // All of the functions below return Cursor objects.\n    var motions = {\n      moveToTopLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).top + motionArgs.repeat -1;\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToMiddleLine: function(cm) {\n        var range = getUserVisibleLines(cm);\n        var line = Math.floor((range.top + range.bottom) * 0.5);\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToBottomLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat +1;\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      expandToLine: function(_cm, head, motionArgs) {\n        // Expands forward to end of line, and then to next line if repeat is\n        // >1. Does not handle backward motion!\n        var cur = head;\n        return Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      },\n      findNext: function(cm, _head, motionArgs) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        if (!query) {\n          return;\n        }\n        var prev = !motionArgs.forward;\n        // If search is initiated with ? instead of /, negate direction.\n        prev = (state.isReversed()) ? !prev : prev;\n        highlightSearchMatches(cm, query);\n        return findNext(cm, prev/** prev */, query, motionArgs.repeat);\n      },\n      goToMark: function(cm, _head, motionArgs, vim) {\n        var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\n        if (pos) {\n          return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;\n        }\n        return null;\n      },\n      moveToOtherHighlightedEnd: function(cm, _head, motionArgs, vim) {\n        if (vim.visualBlock && motionArgs.sameLine) {\n          var sel = vim.sel;\n          return [\n            clipCursorToContent(cm, Pos(sel.anchor.line, sel.head.ch)),\n            clipCursorToContent(cm, Pos(sel.head.line, sel.anchor.ch))\n          ];\n        } else {\n          return ([vim.sel.head, vim.sel.anchor]);\n        }\n      },\n      jumpToMark: function(cm, head, motionArgs, vim) {\n        var best = head;\n        for (var i = 0; i < motionArgs.repeat; i++) {\n          var cursor = best;\n          for (var key in vim.marks) {\n            if (!isLowerCase(key)) {\n              continue;\n            }\n            var mark = vim.marks[key].find();\n            var isWrongDirection = (motionArgs.forward) ?\n              cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n\n            if (isWrongDirection) {\n              continue;\n            }\n            if (motionArgs.linewise && (mark.line == cursor.line)) {\n              continue;\n            }\n\n            var equal = cursorEqual(cursor, best);\n            var between = (motionArgs.forward) ?\n              cursorIsBetween(cursor, mark, best) :\n              cursorIsBetween(best, mark, cursor);\n\n            if (equal || between) {\n              best = mark;\n            }\n          }\n        }\n\n        if (motionArgs.linewise) {\n          // Vim places the cursor on the first non-whitespace character of\n          // the line if there is one, else it places the cursor at the end\n          // of the line, regardless of whether a mark was found.\n          best = Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n        }\n        return best;\n      },\n      moveByCharacters: function(_cm, head, motionArgs) {\n        var cur = head;\n        var repeat = motionArgs.repeat;\n        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n        return Pos(cur.line, ch);\n      },\n      moveByLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        var endCh = cur.ch;\n        // Depending what our last motion was, we may want to do different\n        // things. If our last motion was moving vertically, we want to\n        // preserve the HPos from our last horizontal move.  If our last motion\n        // was going to the end of a line, moving vertically we should go to\n        // the end of the line, etc.\n        switch (vim.lastMotion) {\n          case this.moveByLines:\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveToColumn:\n          case this.moveToEol:\n            endCh = vim.lastHPos;\n            break;\n          default:\n            vim.lastHPos = endCh;\n        }\n        var repeat = motionArgs.repeat+(motionArgs.repeatOffset||0);\n        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n        var first = cm.firstLine();\n        var last = cm.lastLine();\n        // Vim go to line begin or line end when cursor at first/last line and\n        // move to previous/next line is triggered.\n        if (line < first && cur.line == first){\n          return this.moveToStartOfLine(cm, head, motionArgs, vim);\n        }else if (line > last && cur.line == last){\n            return this.moveToEol(cm, head, motionArgs, vim, true);\n        }\n        if (motionArgs.toFirstChar){\n          endCh=findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n          vim.lastHPos = endCh;\n        }\n        vim.lastHSPos = cm.charCoords(Pos(line, endCh),'div').left;\n        return Pos(line, endCh);\n      },\n      moveByDisplayLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        switch (vim.lastMotion) {\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveByLines:\n          case this.moveToColumn:\n          case this.moveToEol:\n            break;\n          default:\n            vim.lastHSPos = cm.charCoords(cur,'div').left;\n        }\n        var repeat = motionArgs.repeat;\n        var res=cm.findPosV(cur,(motionArgs.forward ? repeat : -repeat),'line',vim.lastHSPos);\n        if (res.hitSide) {\n          if (motionArgs.forward) {\n            var lastCharCoords = cm.charCoords(res, 'div');\n            var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };\n            var res = cm.coordsChar(goalCoords, 'div');\n          } else {\n            var resCoords = cm.charCoords(Pos(cm.firstLine(), 0), 'div');\n            resCoords.left = vim.lastHSPos;\n            res = cm.coordsChar(resCoords, 'div');\n          }\n        }\n        vim.lastHPos = res.ch;\n        return res;\n      },\n      moveByPage: function(cm, head, motionArgs) {\n        // CodeMirror only exposes functions that move the cursor page down, so\n        // doing this bad hack to move the cursor and move it back. evalInput\n        // will move the cursor to where it should be in the end.\n        var curStart = head;\n        var repeat = motionArgs.repeat;\n        return cm.findPosV(curStart, (motionArgs.forward ? repeat : -repeat), 'page');\n      },\n      moveByParagraph: function(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findParagraph(cm, head, motionArgs.repeat, dir);\n      },\n      moveBySentence: function(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findSentence(cm, head, motionArgs.repeat, dir);\n      },\n      moveByScroll: function(cm, head, motionArgs, vim) {\n        var scrollbox = cm.getScrollInfo();\n        var curEnd = null;\n        var repeat = motionArgs.repeat;\n        if (!repeat) {\n          repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n        }\n        var orig = cm.charCoords(head, 'local');\n        motionArgs.repeat = repeat;\n        var curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n        if (!curEnd) {\n          return null;\n        }\n        var dest = cm.charCoords(curEnd, 'local');\n        cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n        return curEnd;\n      },\n      moveByWords: function(cm, head, motionArgs) {\n        return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward,\n            !!motionArgs.wordEnd, !!motionArgs.bigWord);\n      },\n      moveTillCharacter: function(cm, _head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        var curEnd = moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter);\n        var increment = motionArgs.forward ? -1 : 1;\n        recordLastCharacterSearch(increment, motionArgs);\n        if (!curEnd) return null;\n        curEnd.ch += increment;\n        return curEnd;\n      },\n      moveToCharacter: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        recordLastCharacterSearch(0, motionArgs);\n        return moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToSymbol: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        return findSymbol(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToColumn: function(cm, head, motionArgs, vim) {\n        var repeat = motionArgs.repeat;\n        // repeat is equivalent to which column we want to move to!\n        vim.lastHPos = repeat - 1;\n        vim.lastHSPos = cm.charCoords(head,'div').left;\n        return moveToColumn(cm, repeat);\n      },\n      moveToEol: function(cm, head, motionArgs, vim, keepHPos) {\n        var cur = head;\n        var retval= Pos(cur.line + motionArgs.repeat - 1, Infinity);\n        var end=cm.clipPos(retval);\n        end.ch--;\n        if (!keepHPos) {\n          vim.lastHPos = Infinity;\n          vim.lastHSPos = cm.charCoords(end,'div').left;\n        }\n        return retval;\n      },\n      moveToFirstNonWhiteSpaceCharacter: function(cm, head) {\n        // Go to the start of the line where the text begins, or the end for\n        // whitespace-only lines\n        var cursor = head;\n        return Pos(cursor.line,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n      },\n      moveToMatchedSymbol: function(cm, head) {\n        var cursor = head;\n        var line = cursor.line;\n        var ch = cursor.ch;\n        var lineText = cm.getLine(line);\n        var symbol;\n        for (; ch < lineText.length; ch++) {\n          symbol = lineText.charAt(ch);\n          if (symbol && isMatchableSymbol(symbol)) {\n            var style = cm.getTokenTypeAt(Pos(line, ch + 1));\n            if (style !== \"string\" && style !== \"comment\") {\n              break;\n            }\n          }\n        }\n        if (ch < lineText.length) {\n          // Only include angle brackets in analysis if they are being matched.\n          var re = (ch === '<' || ch === '>') ? /[(){}[\\]<>]/ : /[(){}[\\]]/;\n          var matched = cm.findMatchingBracket(Pos(line, ch), {bracketRegex: re});\n          return matched.to;\n        } else {\n          return cursor;\n        }\n      },\n      moveToStartOfLine: function(_cm, head) {\n        return Pos(head.line, 0);\n      },\n      moveToLineOrEdgeOfDocument: function(cm, _head, motionArgs) {\n        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n        if (motionArgs.repeatIsExplicit) {\n          lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n        }\n        return Pos(lineNum,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n      },\n      textObjectManipulation: function(cm, head, motionArgs, vim) {\n        // TODO: lots of possible exceptions that can be thrown here. Try da(\n        //     outside of a () block.\n        var mirroredPairs = {'(': ')', ')': '(',\n                             '{': '}', '}': '{',\n                             '[': ']', ']': '[',\n                             '<': '>', '>': '<'};\n        var selfPaired = {'\\'': true, '\"': true, '`': true};\n\n        var character = motionArgs.selectedCharacter;\n        // 'b' refers to  '()' block.\n        // 'B' refers to  '{}' block.\n        if (character == 'b') {\n          character = '(';\n        } else if (character == 'B') {\n          character = '{';\n        }\n\n        // Inclusive is the difference between a and i\n        // TODO: Instead of using the additional text object map to perform text\n        //     object operations, merge the map into the defaultKeyMap and use\n        //     motionArgs to define behavior. Define separate entries for 'aw',\n        //     'iw', 'a[', 'i[', etc.\n        var inclusive = !motionArgs.textObjectInner;\n\n        var tmp;\n        if (mirroredPairs[character]) {\n          tmp = selectCompanionObject(cm, head, character, inclusive);\n        } else if (selfPaired[character]) {\n          tmp = findBeginningAndEnd(cm, head, character, inclusive);\n        } else if (character === 'W') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     true /** bigWord */);\n        } else if (character === 'w') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     false /** bigWord */);\n        } else if (character === 'p') {\n          tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n          motionArgs.linewise = true;\n          if (vim.visualMode) {\n            if (!vim.visualLine) { vim.visualLine = true; }\n          } else {\n            var operatorArgs = vim.inputState.operatorArgs;\n            if (operatorArgs) { operatorArgs.linewise = true; }\n            tmp.end.line--;\n          }\n        } else {\n          // No text object defined for this, don't move.\n          return null;\n        }\n\n        if (!cm.state.vim.visualMode) {\n          return [tmp.start, tmp.end];\n        } else {\n          return expandSelection(cm, tmp.start, tmp.end);\n        }\n      },\n\n      repeatLastCharacterSearch: function(cm, head, motionArgs) {\n        var lastSearch = vimGlobalState.lastCharacterSearch;\n        var repeat = motionArgs.repeat;\n        var forward = motionArgs.forward === lastSearch.forward;\n        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n        cm.moveH(-increment, 'char');\n        motionArgs.inclusive = forward ? true : false;\n        var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n        if (!curEnd) {\n          cm.moveH(increment, 'char');\n          return head;\n        }\n        curEnd.ch += increment;\n        return curEnd;\n      }\n    };\n\n    function defineMotion(name, fn) {\n      motions[name] = fn;\n    }\n\n    function fillArray(val, times) {\n      var arr = [];\n      for (var i = 0; i < times; i++) {\n        arr.push(val);\n      }\n      return arr;\n    }\n    /**\n     * An operator acts on a text selection. It receives the list of selections\n     * as input. The corresponding CodeMirror selection is guaranteed to\n    * match the input selection.\n     */\n    var operators = {\n      change: function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        if (!vim.visualMode) {\n          var anchor = ranges[0].anchor,\n              head = ranges[0].head;\n          text = cm.getRange(anchor, head);\n          var lastState = vim.lastEditInputState || {};\n          if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n            // Exclude trailing whitespace if the range is not all whitespace.\n            var match = (/\\s+$/).exec(text);\n            if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n              head = offsetCursor(head, 0, - match[0].length);\n              text = text.slice(0, - match[0].length);\n            }\n          }\n          var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);\n          var wasLastLine = cm.firstLine() == cm.lastLine();\n          if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {\n            cm.replaceRange('', prevLineEnd, head);\n          } else {\n            cm.replaceRange('', anchor, head);\n          }\n          if (args.linewise) {\n            // Push the next line back down, if there is a next line.\n            if (!wasLastLine) {\n              cm.setCursor(prevLineEnd);\n              CodeMirror.commands.newlineAndIndent(cm);\n            }\n            // make sure cursor ends up at the end of the line.\n            anchor.ch = Number.MAX_VALUE;\n          }\n          finalHead = anchor;\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'change', text,\n            args.linewise, ranges.length > 1);\n        actions.enterInsertMode(cm, {head: finalHead}, cm.state.vim);\n      },\n      // delete is a javascript keyword.\n      'delete': function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        if (!vim.visualBlock) {\n          var anchor = ranges[0].anchor,\n              head = ranges[0].head;\n          if (args.linewise &&\n              head.line != cm.firstLine() &&\n              anchor.line == cm.lastLine() &&\n              anchor.line == head.line - 1) {\n            // Special case for dd on last line (and first line).\n            if (anchor.line == cm.firstLine()) {\n              anchor.ch = 0;\n            } else {\n              anchor = Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n            }\n          }\n          text = cm.getRange(anchor, head);\n          cm.replaceRange('', anchor, head);\n          finalHead = anchor;\n          if (args.linewise) {\n            finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n          }\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = ranges[0].anchor;\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'delete', text,\n            args.linewise, vim.visualBlock);\n        var includeLineBreak = vim.insertMode\n        return clipCursorToContent(cm, finalHead, includeLineBreak);\n      },\n      indent: function(cm, args, ranges) {\n        var vim = cm.state.vim;\n        var startLine = ranges[0].anchor.line;\n        var endLine = vim.visualBlock ?\n          ranges[ranges.length - 1].anchor.line :\n          ranges[0].head.line;\n        // In visual mode, n> shifts the selection right n times, instead of\n        // shifting n lines right once.\n        var repeat = (vim.visualMode) ? args.repeat : 1;\n        if (args.linewise) {\n          // The only way to delete a newline is to delete until the start of\n          // the next line, so in linewise mode evalInput will include the next\n          // line. We don't want this in indent, so we go back a line.\n          endLine--;\n        }\n        for (var i = startLine; i <= endLine; i++) {\n          for (var j = 0; j < repeat; j++) {\n            cm.indentLine(i, args.indentRight);\n          }\n        }\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      indentAuto: function(cm, _args, ranges) {\n        cm.execCommand(\"indentAuto\");\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      changeCase: function(cm, args, ranges, oldAnchor, newHead) {\n        var selections = cm.getSelections();\n        var swapped = [];\n        var toLower = args.toLower;\n        for (var j = 0; j < selections.length; j++) {\n          var toSwap = selections[j];\n          var text = '';\n          if (toLower === true) {\n            text = toSwap.toLowerCase();\n          } else if (toLower === false) {\n            text = toSwap.toUpperCase();\n          } else {\n            for (var i = 0; i < toSwap.length; i++) {\n              var character = toSwap.charAt(i);\n              text += isUpperCase(character) ? character.toLowerCase() :\n                  character.toUpperCase();\n            }\n          }\n          swapped.push(text);\n        }\n        cm.replaceSelections(swapped);\n        if (args.shouldMoveCursor){\n          return newHead;\n        } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n          return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n        } else if (args.linewise){\n          return oldAnchor;\n        } else {\n          return cursorMin(ranges[0].anchor, ranges[0].head);\n        }\n      },\n      yank: function(cm, args, ranges, oldAnchor) {\n        var vim = cm.state.vim;\n        var text = cm.getSelection();\n        var endPos = vim.visualMode\n          ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor)\n          : oldAnchor;\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'yank',\n            text, args.linewise, vim.visualBlock);\n        return endPos;\n      }\n    };\n\n    function defineOperator(name, fn) {\n      operators[name] = fn;\n    }\n\n    var actions = {\n      jumpListWalk: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat;\n        var forward = actionArgs.forward;\n        var jumpList = vimGlobalState.jumpList;\n\n        var mark = jumpList.move(cm, forward ? repeat : -repeat);\n        var markPos = mark ? mark.find() : undefined;\n        markPos = markPos ? markPos : cm.getCursor();\n        cm.setCursor(markPos);\n      },\n      scroll: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat || 1;\n        var lineHeight = cm.defaultTextHeight();\n        var top = cm.getScrollInfo().top;\n        var delta = lineHeight * repeat;\n        var newPos = actionArgs.forward ? top + delta : top - delta;\n        var cursor = copyCursor(cm.getCursor());\n        var cursorCoords = cm.charCoords(cursor, 'local');\n        if (actionArgs.forward) {\n          if (newPos > cursorCoords.top) {\n             cursor.line += (newPos - cursorCoords.top) / lineHeight;\n             cursor.line = Math.ceil(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(null, cursorCoords.top);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        } else {\n          var newBottom = newPos + cm.getScrollInfo().clientHeight;\n          if (newBottom < cursorCoords.bottom) {\n             cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n             cursor.line = Math.floor(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(\n                 null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        }\n      },\n      scrollToCursor: function(cm, actionArgs) {\n        var lineNum = cm.getCursor().line;\n        var charCoords = cm.charCoords(Pos(lineNum, 0), 'local');\n        var height = cm.getScrollInfo().clientHeight;\n        var y = charCoords.top;\n        var lineHeight = charCoords.bottom - y;\n        switch (actionArgs.position) {\n          case 'center': y = y - (height / 2) + lineHeight;\n            break;\n          case 'bottom': y = y - height + lineHeight;\n            break;\n        }\n        cm.scrollTo(null, y);\n      },\n      replayMacro: function(cm, actionArgs, vim) {\n        var registerName = actionArgs.selectedCharacter;\n        var repeat = actionArgs.repeat;\n        var macroModeState = vimGlobalState.macroModeState;\n        if (registerName == '@') {\n          registerName = macroModeState.latestRegister;\n        } else {\n          macroModeState.latestRegister = registerName;\n        }\n        while(repeat--){\n          executeMacroRegister(cm, vim, macroModeState, registerName);\n        }\n      },\n      enterMacroRecordMode: function(cm, actionArgs) {\n        var macroModeState = vimGlobalState.macroModeState;\n        var registerName = actionArgs.selectedCharacter;\n        if (vimGlobalState.registerController.isValidRegister(registerName)) {\n          macroModeState.enterMacroRecordMode(cm, registerName);\n        }\n      },\n      toggleOverwrite: function(cm) {\n        if (!cm.state.overwrite) {\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n      },\n      enterInsertMode: function(cm, actionArgs, vim) {\n        if (cm.getOption('readOnly')) { return; }\n        vim.insertMode = true;\n        vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n        var insertAt = (actionArgs) ? actionArgs.insertAt : null;\n        var sel = vim.sel;\n        var head = actionArgs.head || cm.getCursor('head');\n        var height = cm.listSelections().length;\n        if (insertAt == 'eol') {\n          head = Pos(head.line, lineLength(cm, head.line));\n        } else if (insertAt == 'charAfter') {\n          head = offsetCursor(head, 0, 1);\n        } else if (insertAt == 'firstNonBlank') {\n          head = motions.moveToFirstNonWhiteSpaceCharacter(cm, head);\n        } else if (insertAt == 'startOfSelectedArea') {\n          if (!vim.visualMode)\n              return;\n          if (!vim.visualBlock) {\n            if (sel.head.line < sel.anchor.line) {\n              head = sel.head;\n            } else {\n              head = Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.min(sel.head.ch, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'endOfSelectedArea') {\n            if (!vim.visualMode)\n              return;\n          if (!vim.visualBlock) {\n            if (sel.head.line >= sel.anchor.line) {\n              head = offsetCursor(sel.head, 0, 1);\n            } else {\n              head = Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.max(sel.head.ch + 1, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'inplace') {\n          if (vim.visualMode){\n            return;\n          }\n        }\n        cm.setOption('disableInput', false);\n        if (actionArgs && actionArgs.replace) {\n          // Handle Replace-mode as a special case of insert mode.\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n        if (!vimGlobalState.macroModeState.isPlaying) {\n          // Only record if not replaying.\n          cm.on('change', onChange);\n          CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        selectForInsert(cm, head, height);\n      },\n      toggleVisualMode: function(cm, actionArgs, vim) {\n        var repeat = actionArgs.repeat;\n        var anchor = cm.getCursor();\n        var head;\n        // TODO: The repeat should actually select number of characters/lines\n        //     equal to the repeat times the size of the previous visual\n        //     operation.\n        if (!vim.visualMode) {\n          // Entering visual mode\n          vim.visualMode = true;\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          head = clipCursorToContent(\n              cm, Pos(anchor.line, anchor.ch + repeat - 1),\n              true /** includeLineBreak */);\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n        } else if (vim.visualLine ^ actionArgs.linewise ||\n            vim.visualBlock ^ actionArgs.blockwise) {\n          // Toggling between modes\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n        } else {\n          exitVisualMode(cm);\n        }\n      },\n      reselectLastSelection: function(cm, _actionArgs, vim) {\n        var lastSelection = vim.lastSelection;\n        if (vim.visualMode) {\n          updateLastSelection(cm, vim);\n        }\n        if (lastSelection) {\n          var anchor = lastSelection.anchorMark.find();\n          var head = lastSelection.headMark.find();\n          if (!anchor || !head) {\n            // If the marks have been destroyed due to edits, do nothing.\n            return;\n          }\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          vim.visualMode = true;\n          vim.visualLine = lastSelection.visualLine;\n          vim.visualBlock = lastSelection.visualBlock;\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n          CodeMirror.signal(cm, 'vim-mode-change', {\n            mode: 'visual',\n            subMode: vim.visualLine ? 'linewise' :\n                     vim.visualBlock ? 'blockwise' : ''});\n        }\n      },\n      joinLines: function(cm, actionArgs, vim) {\n        var curStart, curEnd;\n        if (vim.visualMode) {\n          curStart = cm.getCursor('anchor');\n          curEnd = cm.getCursor('head');\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curEnd;\n            curEnd = curStart;\n            curStart = tmp;\n          }\n          curEnd.ch = lineLength(cm, curEnd.line) - 1;\n        } else {\n          // Repeat is the number of lines to join. Minimum 2 lines.\n          var repeat = Math.max(actionArgs.repeat, 2);\n          curStart = cm.getCursor();\n          curEnd = clipCursorToContent(cm, Pos(curStart.line + repeat - 1,\n                                               Infinity));\n        }\n        var finalCh = 0;\n        for (var i = curStart.line; i < curEnd.line; i++) {\n          finalCh = lineLength(cm, curStart.line);\n          var tmp = Pos(curStart.line + 1,\n                        lineLength(cm, curStart.line + 1));\n          var text = cm.getRange(curStart, tmp);\n          text = text.replace(/\\n\\s*/g, ' ');\n          cm.replaceRange(text, curStart, tmp);\n        }\n        var curFinalPos = Pos(curStart.line, finalCh);\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curFinalPos);\n      },\n      newLineAndEnterInsertMode: function(cm, actionArgs, vim) {\n        vim.insertMode = true;\n        var insertAt = copyCursor(cm.getCursor());\n        if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n          // Special case for inserting newline before start of document.\n          cm.replaceRange('\\n', Pos(cm.firstLine(), 0));\n          cm.setCursor(cm.firstLine(), 0);\n        } else {\n          insertAt.line = (actionArgs.after) ? insertAt.line :\n              insertAt.line - 1;\n          insertAt.ch = lineLength(cm, insertAt.line);\n          cm.setCursor(insertAt);\n          var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment ||\n              CodeMirror.commands.newlineAndIndent;\n          newlineFn(cm);\n        }\n        this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);\n      },\n      paste: function(cm, actionArgs, vim) {\n        var cur = copyCursor(cm.getCursor());\n        var register = vimGlobalState.registerController.getRegister(\n            actionArgs.registerName);\n        var text = register.toString();\n        if (!text) {\n          return;\n        }\n        if (actionArgs.matchIndent) {\n          var tabSize = cm.getOption(\"tabSize\");\n          // length that considers tabs and tabSize\n          var whitespaceLength = function(str) {\n            var tabs = (str.split(\"\\t\").length - 1);\n            var spaces = (str.split(\" \").length - 1);\n            return tabs * tabSize + spaces * 1;\n          };\n          var currentLine = cm.getLine(cm.getCursor().line);\n          var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\n          // chomp last newline b/c don't want it to match /^\\s*/gm\n          var chompedText = text.replace(/\\n$/, '');\n          var wasChomped = text !== chompedText;\n          var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n          var text = chompedText.replace(/^\\s*/gm, function(wspace) {\n            var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n            if (newIndent < 0) {\n              return \"\";\n            }\n            else if (cm.getOption(\"indentWithTabs\")) {\n              var quotient = Math.floor(newIndent / tabSize);\n              return Array(quotient + 1).join('\\t');\n            }\n            else {\n              return Array(newIndent + 1).join(' ');\n            }\n          });\n          text += wasChomped ? \"\\n\" : \"\";\n        }\n        if (actionArgs.repeat > 1) {\n          var text = Array(actionArgs.repeat + 1).join(text);\n        }\n        var linewise = register.linewise;\n        var blockwise = register.blockwise;\n        if (blockwise) {\n          text = text.split('\\n');\n          if (linewise) {\n              text.pop();\n          }\n          for (var i = 0; i < text.length; i++) {\n            text[i] = (text[i] == '') ? ' ' : text[i];\n          }\n          cur.ch += actionArgs.after ? 1 : 0;\n          cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);\n        } else if (linewise) {\n          if(vim.visualMode) {\n            text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n          } else if (actionArgs.after) {\n            // Move the newline at the end to the start instead, and paste just\n            // before the newline character of the line we are on right now.\n            text = '\\n' + text.slice(0, text.length - 1);\n            cur.ch = lineLength(cm, cur.line);\n          } else {\n            cur.ch = 0;\n          }\n        } else {\n          cur.ch += actionArgs.after ? 1 : 0;\n        }\n        var curPosFinal;\n        var idx;\n        if (vim.visualMode) {\n          //  save the pasted text for reselection if the need arises\n          vim.lastPastedText = text;\n          var lastSelectionCurEnd;\n          var selectedArea = getSelectedAreaRange(cm, vim);\n          var selectionStart = selectedArea[0];\n          var selectionEnd = selectedArea[1];\n          var selectedText = cm.getSelection();\n          var selections = cm.listSelections();\n          var emptyStrings = new Array(selections.length).join('1').split('1');\n          // save the curEnd marker before it get cleared due to cm.replaceRange.\n          if (vim.lastSelection) {\n            lastSelectionCurEnd = vim.lastSelection.headMark.find();\n          }\n          // push the previously selected text to unnamed register\n          vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n          if (blockwise) {\n            // first delete the selected text\n            cm.replaceSelections(emptyStrings);\n            // Set new selections as per the block length of the yanked text\n            selectionEnd = Pos(selectionStart.line + text.length-1, selectionStart.ch);\n            cm.setCursor(selectionStart);\n            selectBlock(cm, selectionEnd);\n            cm.replaceSelections(text);\n            curPosFinal = selectionStart;\n          } else if (vim.visualBlock) {\n            cm.replaceSelections(emptyStrings);\n            cm.setCursor(selectionStart);\n            cm.replaceRange(text, selectionStart, selectionStart);\n            curPosFinal = selectionStart;\n          } else {\n            cm.replaceRange(text, selectionStart, selectionEnd);\n            curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n          }\n          // restore the the curEnd marker\n          if(lastSelectionCurEnd) {\n            vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n          }\n          if (linewise) {\n            curPosFinal.ch=0;\n          }\n        } else {\n          if (blockwise) {\n            cm.setCursor(cur);\n            for (var i = 0; i < text.length; i++) {\n              var line = cur.line+i;\n              if (line > cm.lastLine()) {\n                cm.replaceRange('\\n',  Pos(line, 0));\n              }\n              var lastCh = lineLength(cm, line);\n              if (lastCh < cur.ch) {\n                extendLineToColumn(cm, line, cur.ch);\n              }\n            }\n            cm.setCursor(cur);\n            selectBlock(cm, Pos(cur.line + text.length-1, cur.ch));\n            cm.replaceSelections(text);\n            curPosFinal = cur;\n          } else {\n            cm.replaceRange(text, cur);\n            // Now fine tune the cursor to where we want it.\n            if (linewise && actionArgs.after) {\n              curPosFinal = Pos(\n              cur.line + 1,\n              findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));\n            } else if (linewise && !actionArgs.after) {\n              curPosFinal = Pos(\n                cur.line,\n                findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));\n            } else if (!linewise && actionArgs.after) {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length - 1);\n            } else {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length);\n            }\n          }\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curPosFinal);\n      },\n      undo: function(cm, actionArgs) {\n        cm.operation(function() {\n          repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n          cm.setCursor(cm.getCursor('anchor'));\n        });\n      },\n      redo: function(cm, actionArgs) {\n        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n      },\n      setRegister: function(_cm, actionArgs, vim) {\n        vim.inputState.registerName = actionArgs.selectedCharacter;\n      },\n      setMark: function(cm, actionArgs, vim) {\n        var markName = actionArgs.selectedCharacter;\n        updateMark(cm, vim, markName, cm.getCursor());\n      },\n      replace: function(cm, actionArgs, vim) {\n        var replaceWith = actionArgs.selectedCharacter;\n        var curStart = cm.getCursor();\n        var replaceTo;\n        var curEnd;\n        var selections = cm.listSelections();\n        if (vim.visualMode) {\n          curStart = cm.getCursor('start');\n          curEnd = cm.getCursor('end');\n        } else {\n          var line = cm.getLine(curStart.line);\n          replaceTo = curStart.ch + actionArgs.repeat;\n          if (replaceTo > line.length) {\n            replaceTo=line.length;\n          }\n          curEnd = Pos(curStart.line, replaceTo);\n        }\n        if (replaceWith=='\\n') {\n          if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);\n          // special case, where vim help says to replace by just one line-break\n          (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n        } else {\n          var replaceWithStr = cm.getRange(curStart, curEnd);\n          //replace all characters in range by selected, but keep linebreaks\n          replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n          if (vim.visualBlock) {\n            // Tabs are split in visua block before replacing\n            var spaces = new Array(cm.getOption(\"tabSize\")+1).join(' ');\n            replaceWithStr = cm.getSelection();\n            replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n            cm.replaceSelections(replaceWithStr);\n          } else {\n            cm.replaceRange(replaceWithStr, curStart, curEnd);\n          }\n          if (vim.visualMode) {\n            curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ?\n                         selections[0].anchor : selections[0].head;\n            cm.setCursor(curStart);\n            exitVisualMode(cm, false);\n          } else {\n            cm.setCursor(offsetCursor(curEnd, 0, -1));\n          }\n        }\n      },\n      incrementNumberToken: function(cm, actionArgs) {\n        var cur = cm.getCursor();\n        var lineStr = cm.getLine(cur.line);\n        var re = /(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;\n        var match;\n        var start;\n        var end;\n        var numberStr;\n        while ((match = re.exec(lineStr)) !== null) {\n          start = match.index;\n          end = start + match[0].length;\n          if (cur.ch < end)break;\n        }\n        if (!actionArgs.backtrack && (end <= cur.ch))return;\n        if (match) {\n          var baseStr = match[2] || match[4]\n          var digits = match[3] || match[5]\n          var increment = actionArgs.increase ? 1 : -1;\n          var base = {'0b': 2, '0': 8, '': 10, '0x': 16}[baseStr.toLowerCase()];\n          var number = parseInt(match[1] + digits, base) + (increment * actionArgs.repeat);\n          numberStr = number.toString(base);\n          var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : ''\n          if (numberStr.charAt(0) === '-') {\n            numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);\n          } else {\n            numberStr = baseStr + zeroPadding + numberStr;\n          }\n          var from = Pos(cur.line, start);\n          var to = Pos(cur.line, end);\n          cm.replaceRange(numberStr, from, to);\n        } else {\n          return;\n        }\n        cm.setCursor(Pos(cur.line, start + numberStr.length - 1));\n      },\n      repeatLastEdit: function(cm, actionArgs, vim) {\n        var lastEditInputState = vim.lastEditInputState;\n        if (!lastEditInputState) { return; }\n        var repeat = actionArgs.repeat;\n        if (repeat && actionArgs.repeatIsExplicit) {\n          vim.lastEditInputState.repeatOverride = repeat;\n        } else {\n          repeat = vim.lastEditInputState.repeatOverride || repeat;\n        }\n        repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\n      },\n      indent: function(cm, actionArgs) {\n        cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n      },\n      exitInsertMode: exitInsertMode\n    };\n\n    function defineAction(name, fn) {\n      actions[name] = fn;\n    }\n\n    /*\n     * Below are miscellaneous utility functions used by vim.js\n     */\n\n    /**\n     * Clips cursor to ensure that line is within the buffer's range\n     * If includeLineBreak is true, then allow cur.ch == lineLength.\n     */\n    function clipCursorToContent(cm, cur, includeLineBreak) {\n      var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine() );\n      var maxCh = lineLength(cm, line) - 1;\n      maxCh = (includeLineBreak) ? maxCh + 1 : maxCh;\n      var ch = Math.min(Math.max(0, cur.ch), maxCh);\n      return Pos(line, ch);\n    }\n    function copyArgs(args) {\n      var ret = {};\n      for (var prop in args) {\n        if (args.hasOwnProperty(prop)) {\n          ret[prop] = args[prop];\n        }\n      }\n      return ret;\n    }\n    function offsetCursor(cur, offsetLine, offsetCh) {\n      if (typeof offsetLine === 'object') {\n        offsetCh = offsetLine.ch;\n        offsetLine = offsetLine.line;\n      }\n      return Pos(cur.line + offsetLine, cur.ch + offsetCh);\n    }\n    function commandMatches(keys, keyMap, context, inputState) {\n      // Partial matches are not applied. They inform the key handler\n      // that the current key sequence is a subsequence of a valid key\n      // sequence, so that the key buffer is not cleared.\n      var match, partial = [], full = [];\n      for (var i = 0; i < keyMap.length; i++) {\n        var command = keyMap[i];\n        if (context == 'insert' && command.context != 'insert' ||\n            command.context && command.context != context ||\n            inputState.operator && command.type == 'action' ||\n            !(match = commandMatch(keys, command.keys))) { continue; }\n        if (match == 'partial') { partial.push(command); }\n        if (match == 'full') { full.push(command); }\n      }\n      return {\n        partial: partial.length && partial,\n        full: full.length && full\n      };\n    }\n    function commandMatch(pressed, mapped) {\n      if (mapped.slice(-11) == '<character>') {\n        // Last character matches anything.\n        var prefixLen = mapped.length - 11;\n        var pressedPrefix = pressed.slice(0, prefixLen);\n        var mappedPrefix = mapped.slice(0, prefixLen);\n        return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' :\n               mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n      } else {\n        return pressed == mapped ? 'full' :\n               mapped.indexOf(pressed) == 0 ? 'partial' : false;\n      }\n    }\n    function lastChar(keys) {\n      var match = /^.*(<[^>]+>)$/.exec(keys);\n      var selectedCharacter = match ? match[1] : keys.slice(-1);\n      if (selectedCharacter.length > 1){\n        switch(selectedCharacter){\n          case '<CR>':\n            selectedCharacter='\\n';\n            break;\n          case '<Space>':\n            selectedCharacter=' ';\n            break;\n          default:\n            selectedCharacter='';\n            break;\n        }\n      }\n      return selectedCharacter;\n    }\n    function repeatFn(cm, fn, repeat) {\n      return function() {\n        for (var i = 0; i < repeat; i++) {\n          fn(cm);\n        }\n      };\n    }\n    function copyCursor(cur) {\n      return Pos(cur.line, cur.ch);\n    }\n    function cursorEqual(cur1, cur2) {\n      return cur1.ch == cur2.ch && cur1.line == cur2.line;\n    }\n    function cursorIsBefore(cur1, cur2) {\n      if (cur1.line < cur2.line) {\n        return true;\n      }\n      if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n        return true;\n      }\n      return false;\n    }\n    function cursorMin(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n    }\n    function cursorMax(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n    }\n    function cursorIsBetween(cur1, cur2, cur3) {\n      // returns true if cur2 is between cur1 and cur3.\n      var cur1before2 = cursorIsBefore(cur1, cur2);\n      var cur2before3 = cursorIsBefore(cur2, cur3);\n      return cur1before2 && cur2before3;\n    }\n    function lineLength(cm, lineNum) {\n      return cm.getLine(lineNum).length;\n    }\n    function trim(s) {\n      if (s.trim) {\n        return s.trim();\n      }\n      return s.replace(/^\\s+|\\s+$/g, '');\n    }\n    function escapeRegex(s) {\n      return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n    }\n    function extendLineToColumn(cm, lineNum, column) {\n      var endCh = lineLength(cm, lineNum);\n      var spaces = new Array(column-endCh+1).join(' ');\n      cm.setCursor(Pos(lineNum, endCh));\n      cm.replaceRange(spaces, cm.getCursor());\n    }\n    // This functions selects a rectangular block\n    // of text with selectionEnd as any of its corner\n    // Height of block:\n    // Difference in selectionEnd.line and first/last selection.line\n    // Width of the block:\n    // Distance between selectionEnd.ch and any(first considered here) selection.ch\n    function selectBlock(cm, selectionEnd) {\n      var selections = [], ranges = cm.listSelections();\n      var head = copyCursor(cm.clipPos(selectionEnd));\n      var isClipped = !cursorEqual(selectionEnd, head);\n      var curHead = cm.getCursor('head');\n      var primIndex = getIndex(ranges, curHead);\n      var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n      var max = ranges.length - 1;\n      var index = max - primIndex > primIndex ? max : 0;\n      var base = ranges[index].anchor;\n\n      var firstLine = Math.min(base.line, head.line);\n      var lastLine = Math.max(base.line, head.line);\n      var baseCh = base.ch, headCh = head.ch;\n\n      var dir = ranges[index].head.ch - baseCh;\n      var newDir = headCh - baseCh;\n      if (dir > 0 && newDir <= 0) {\n        baseCh++;\n        if (!isClipped) { headCh--; }\n      } else if (dir < 0 && newDir >= 0) {\n        baseCh--;\n        if (!wasClipped) { headCh++; }\n      } else if (dir < 0 && newDir == -1) {\n        baseCh--;\n        headCh++;\n      }\n      for (var line = firstLine; line <= lastLine; line++) {\n        var range = {anchor: new Pos(line, baseCh), head: new Pos(line, headCh)};\n        selections.push(range);\n      }\n      cm.setSelections(selections);\n      selectionEnd.ch = headCh;\n      base.ch = baseCh;\n      return base;\n    }\n    function selectForInsert(cm, head, height) {\n      var sel = [];\n      for (var i = 0; i < height; i++) {\n        var lineHead = offsetCursor(head, i, 0);\n        sel.push({anchor: lineHead, head: lineHead});\n      }\n      cm.setSelections(sel, 0);\n    }\n    // getIndex returns the index of the cursor in the selections.\n    function getIndex(ranges, cursor, end) {\n      for (var i = 0; i < ranges.length; i++) {\n        var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n        var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n        if (atAnchor || atHead) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    function getSelectedAreaRange(cm, vim) {\n      var lastSelection = vim.lastSelection;\n      var getCurrentSelectedAreaRange = function() {\n        var selections = cm.listSelections();\n        var start =  selections[0];\n        var end = selections[selections.length-1];\n        var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n        var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n        return [selectionStart, selectionEnd];\n      };\n      var getLastSelectedAreaRange = function() {\n        var selectionStart = cm.getCursor();\n        var selectionEnd = cm.getCursor();\n        var block = lastSelection.visualBlock;\n        if (block) {\n          var width = block.width;\n          var height = block.height;\n          selectionEnd = Pos(selectionStart.line + height, selectionStart.ch + width);\n          var selections = [];\n          // selectBlock creates a 'proper' rectangular block.\n          // We do not want that in all cases, so we manually set selections.\n          for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n            var anchor = Pos(i, selectionStart.ch);\n            var head = Pos(i, selectionEnd.ch);\n            var range = {anchor: anchor, head: head};\n            selections.push(range);\n          }\n          cm.setSelections(selections);\n        } else {\n          var start = lastSelection.anchorMark.find();\n          var end = lastSelection.headMark.find();\n          var line = end.line - start.line;\n          var ch = end.ch - start.ch;\n          selectionEnd = {line: selectionEnd.line + line, ch: line ? selectionEnd.ch : ch + selectionEnd.ch};\n          if (lastSelection.visualLine) {\n            selectionStart = Pos(selectionStart.line, 0);\n            selectionEnd = Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n          }\n          cm.setSelection(selectionStart, selectionEnd);\n        }\n        return [selectionStart, selectionEnd];\n      };\n      if (!vim.visualMode) {\n      // In case of replaying the action.\n        return getLastSelectedAreaRange();\n      } else {\n        return getCurrentSelectedAreaRange();\n      }\n    }\n    // Updates the previous selection with the current selection's values. This\n    // should only be called in visual mode.\n    function updateLastSelection(cm, vim) {\n      var anchor = vim.sel.anchor;\n      var head = vim.sel.head;\n      // To accommodate the effect of lastPastedText in the last selection\n      if (vim.lastPastedText) {\n        head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n        vim.lastPastedText = null;\n      }\n      vim.lastSelection = {'anchorMark': cm.setBookmark(anchor),\n                           'headMark': cm.setBookmark(head),\n                           'anchor': copyCursor(anchor),\n                           'head': copyCursor(head),\n                           'visualMode': vim.visualMode,\n                           'visualLine': vim.visualLine,\n                           'visualBlock': vim.visualBlock};\n    }\n    function expandSelection(cm, start, end) {\n      var sel = cm.state.vim.sel;\n      var head = sel.head;\n      var anchor = sel.anchor;\n      var tmp;\n      if (cursorIsBefore(end, start)) {\n        tmp = end;\n        end = start;\n        start = tmp;\n      }\n      if (cursorIsBefore(head, anchor)) {\n        head = cursorMin(start, head);\n        anchor = cursorMax(anchor, end);\n      } else {\n        anchor = cursorMin(start, anchor);\n        head = cursorMax(head, end);\n        head = offsetCursor(head, 0, -1);\n        if (head.ch == -1 && head.line != cm.firstLine()) {\n          head = Pos(head.line - 1, lineLength(cm, head.line - 1));\n        }\n      }\n      return [anchor, head];\n    }\n    /**\n     * Updates the CodeMirror selection to match the provided vim selection.\n     * If no arguments are given, it uses the current vim selection state.\n     */\n    function updateCmSelection(cm, sel, mode) {\n      var vim = cm.state.vim;\n      sel = sel || vim.sel;\n      var mode = mode ||\n        vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n      var cmSel = makeCmSelection(cm, sel, mode);\n      cm.setSelections(cmSel.ranges, cmSel.primary);\n      updateFakeCursor(cm);\n    }\n    function makeCmSelection(cm, sel, mode, exclusive) {\n      var head = copyCursor(sel.head);\n      var anchor = copyCursor(sel.anchor);\n      if (mode == 'char') {\n        var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        head = offsetCursor(sel.head, 0, headOffset);\n        anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'line') {\n        if (!cursorIsBefore(sel.head, sel.anchor)) {\n          anchor.ch = 0;\n\n          var lastLine = cm.lastLine();\n          if (head.line > lastLine) {\n            head.line = lastLine;\n          }\n          head.ch = lineLength(cm, head.line);\n        } else {\n          head.ch = 0;\n          anchor.ch = lineLength(cm, anchor.line);\n        }\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'block') {\n        var top = Math.min(anchor.line, head.line),\n            left = Math.min(anchor.ch, head.ch),\n            bottom = Math.max(anchor.line, head.line),\n            right = Math.max(anchor.ch, head.ch) + 1;\n        var height = bottom - top + 1;\n        var primary = head.line == top ? 0 : height - 1;\n        var ranges = [];\n        for (var i = 0; i < height; i++) {\n          ranges.push({\n            anchor: Pos(top + i, left),\n            head: Pos(top + i, right)\n          });\n        }\n        return {\n          ranges: ranges,\n          primary: primary\n        };\n      }\n    }\n    function getHead(cm) {\n      var cur = cm.getCursor('head');\n      if (cm.getSelection().length == 1) {\n        // Small corner case when only 1 character is selected. The \"real\"\n        // head is the left of head and anchor.\n        cur = cursorMin(cur, cm.getCursor('anchor'));\n      }\n      return cur;\n    }\n\n    /**\n     * If moveHead is set to false, the CodeMirror selection will not be\n     * touched. The caller assumes the responsibility of putting the cursor\n    * in the right place.\n     */\n    function exitVisualMode(cm, moveHead) {\n      var vim = cm.state.vim;\n      if (moveHead !== false) {\n        cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n      }\n      updateLastSelection(cm, vim);\n      vim.visualMode = false;\n      vim.visualLine = false;\n      vim.visualBlock = false;\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      if (vim.fakeCursor) {\n        vim.fakeCursor.clear();\n      }\n    }\n\n    // Remove any trailing newlines from the selection. For\n    // example, with the caret at the start of the last word on the line,\n    // 'dw' should word, but not the newline, while 'w' should advance the\n    // caret to the first character of the next line.\n    function clipToLine(cm, curStart, curEnd) {\n      var selection = cm.getRange(curStart, curEnd);\n      // Only clip if the selection ends with trailing newline + whitespace\n      if (/\\n\\s*$/.test(selection)) {\n        var lines = selection.split('\\n');\n        // We know this is all whitespace.\n        lines.pop();\n\n        // Cases:\n        // 1. Last word is an empty line - do not clip the trailing '\\n'\n        // 2. Last word is not an empty line - clip the trailing '\\n'\n        var line;\n        // Find the line containing the last word, and clip all whitespace up\n        // to it.\n        for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n          curEnd.line--;\n          curEnd.ch = 0;\n        }\n        // If the last word is not an empty line, clip an additional newline\n        if (line) {\n          curEnd.line--;\n          curEnd.ch = lineLength(cm, curEnd.line);\n        } else {\n          curEnd.ch = 0;\n        }\n      }\n    }\n\n    // Expand the selection to line ends.\n    function expandSelectionToLine(_cm, curStart, curEnd) {\n      curStart.ch = 0;\n      curEnd.ch = 0;\n      curEnd.line++;\n    }\n\n    function findFirstNonWhiteSpaceCharacter(text) {\n      if (!text) {\n        return 0;\n      }\n      var firstNonWS = text.search(/\\S/);\n      return firstNonWS == -1 ? text.length : firstNonWS;\n    }\n\n    function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {\n      var cur = getHead(cm);\n      var line = cm.getLine(cur.line);\n      var idx = cur.ch;\n\n      // Seek to first word or non-whitespace character, depending on if\n      // noSymbol is true.\n      var test = noSymbol ? wordCharTest[0] : bigWordCharTest [0];\n      while (!test(line.charAt(idx))) {\n        idx++;\n        if (idx >= line.length) { return null; }\n      }\n\n      if (bigWord) {\n        test = bigWordCharTest[0];\n      } else {\n        test = wordCharTest[0];\n        if (!test(line.charAt(idx))) {\n          test = wordCharTest[1];\n        }\n      }\n\n      var end = idx, start = idx;\n      while (test(line.charAt(end)) && end < line.length) { end++; }\n      while (test(line.charAt(start)) && start >= 0) { start--; }\n      start++;\n\n      if (inclusive) {\n        // If present, include all whitespace after word.\n        // Otherwise, include all whitespace before word, except indentation.\n        var wordEnd = end;\n        while (/\\s/.test(line.charAt(end)) && end < line.length) { end++; }\n        if (wordEnd == end) {\n          var wordStart = start;\n          while (/\\s/.test(line.charAt(start - 1)) && start > 0) { start--; }\n          if (!start) { start = wordStart; }\n        }\n      }\n      return { start: Pos(cur.line, start), end: Pos(cur.line, end) };\n    }\n\n    function recordJumpPosition(cm, oldCur, newCur) {\n      if (!cursorEqual(oldCur, newCur)) {\n        vimGlobalState.jumpList.add(cm, oldCur, newCur);\n      }\n    }\n\n    function recordLastCharacterSearch(increment, args) {\n        vimGlobalState.lastCharacterSearch.increment = increment;\n        vimGlobalState.lastCharacterSearch.forward = args.forward;\n        vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n    }\n\n    var symbolToMode = {\n        '(': 'bracket', ')': 'bracket', '{': 'bracket', '}': 'bracket',\n        '[': 'section', ']': 'section',\n        '*': 'comment', '/': 'comment',\n        'm': 'method', 'M': 'method',\n        '#': 'preprocess'\n    };\n    var findSymbolModes = {\n      bracket: {\n        isComplete: function(state) {\n          if (state.nextCh === state.symb) {\n            state.depth++;\n            if (state.depth >= 1)return true;\n          } else if (state.nextCh === state.reverseSymb) {\n            state.depth--;\n          }\n          return false;\n        }\n      },\n      section: {\n        init: function(state) {\n          state.curMoveThrough = true;\n          state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n        },\n        isComplete: function(state) {\n          return state.index === 0 && state.nextCh === state.symb;\n        }\n      },\n      comment: {\n        isComplete: function(state) {\n          var found = state.lastCh === '*' && state.nextCh === '/';\n          state.lastCh = state.nextCh;\n          return found;\n        }\n      },\n      // TODO: The original Vim implementation only operates on level 1 and 2.\n      // The current implementation doesn't check for code block level and\n      // therefore it operates on any levels.\n      method: {\n        init: function(state) {\n          state.symb = (state.symb === 'm' ? '{' : '}');\n          state.reverseSymb = state.symb === '{' ? '}' : '{';\n        },\n        isComplete: function(state) {\n          if (state.nextCh === state.symb)return true;\n          return false;\n        }\n      },\n      preprocess: {\n        init: function(state) {\n          state.index = 0;\n        },\n        isComplete: function(state) {\n          if (state.nextCh === '#') {\n            var token = state.lineText.match(/#(\\w+)/)[1];\n            if (token === 'endif') {\n              if (state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth++;\n            } else if (token === 'if') {\n              if (!state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth--;\n            }\n            if (token === 'else' && state.depth === 0)return true;\n          }\n          return false;\n        }\n      }\n    };\n    function findSymbol(cm, repeat, forward, symb) {\n      var cur = copyCursor(cm.getCursor());\n      var increment = forward ? 1 : -1;\n      var endLine = forward ? cm.lineCount() : -1;\n      var curCh = cur.ch;\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      var state = {\n        lineText: lineText,\n        nextCh: lineText.charAt(curCh),\n        lastCh: null,\n        index: curCh,\n        symb: symb,\n        reverseSymb: (forward ?  { ')': '(', '}': '{' } : { '(': ')', '{': '}' })[symb],\n        forward: forward,\n        depth: 0,\n        curMoveThrough: false\n      };\n      var mode = symbolToMode[symb];\n      if (!mode)return cur;\n      var init = findSymbolModes[mode].init;\n      var isComplete = findSymbolModes[mode].isComplete;\n      if (init) { init(state); }\n      while (line !== endLine && repeat) {\n        state.index += increment;\n        state.nextCh = state.lineText.charAt(state.index);\n        if (!state.nextCh) {\n          line += increment;\n          state.lineText = cm.getLine(line) || '';\n          if (increment > 0) {\n            state.index = 0;\n          } else {\n            var lineLen = state.lineText.length;\n            state.index = (lineLen > 0) ? (lineLen-1) : 0;\n          }\n          state.nextCh = state.lineText.charAt(state.index);\n        }\n        if (isComplete(state)) {\n          cur.line = line;\n          cur.ch = state.index;\n          repeat--;\n        }\n      }\n      if (state.nextCh || state.curMoveThrough) {\n        return Pos(line, state.index);\n      }\n      return cur;\n    }\n\n    /*\n     * Returns the boundaries of the next word. If the cursor in the middle of\n     * the word, then returns the boundaries of the current word, starting at\n     * the cursor. If the cursor is at the start/end of a word, and we are going\n     * forward/backward, respectively, find the boundaries of the next word.\n     *\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Cursor} cur The cursor position.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only [a-zA-Z0-9] characters count as part of the word.\n     * @param {boolean} emptyLineIsWord True if empty lines should be treated\n     *     as words.\n     * @return {Object{from:number, to:number, line: number}} The boundaries of\n     *     the word, or null if there are no more words.\n     */\n    function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n      var lineNum = cur.line;\n      var pos = cur.ch;\n      var line = cm.getLine(lineNum);\n      var dir = forward ? 1 : -1;\n      var charTests = bigWord ? bigWordCharTest: wordCharTest;\n\n      if (emptyLineIsWord && line == '') {\n        lineNum += dir;\n        line = cm.getLine(lineNum);\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        pos = (forward) ? 0 : line.length;\n      }\n\n      while (true) {\n        if (emptyLineIsWord && line == '') {\n          return { from: 0, to: 0, line: lineNum };\n        }\n        var stop = (dir > 0) ? line.length : -1;\n        var wordStart = stop, wordEnd = stop;\n        // Find bounds of next word.\n        while (pos != stop) {\n          var foundWord = false;\n          for (var i = 0; i < charTests.length && !foundWord; ++i) {\n            if (charTests[i](line.charAt(pos))) {\n              wordStart = pos;\n              // Advance to end of word.\n              while (pos != stop && charTests[i](line.charAt(pos))) {\n                pos += dir;\n              }\n              wordEnd = pos;\n              foundWord = wordStart != wordEnd;\n              if (wordStart == cur.ch && lineNum == cur.line &&\n                  wordEnd == wordStart + dir) {\n                // We started at the end of a word. Find the next one.\n                continue;\n              } else {\n                return {\n                  from: Math.min(wordStart, wordEnd + 1),\n                  to: Math.max(wordStart, wordEnd),\n                  line: lineNum };\n              }\n            }\n          }\n          if (!foundWord) {\n            pos += dir;\n          }\n        }\n        // Advance to next/prev line.\n        lineNum += dir;\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        line = cm.getLine(lineNum);\n        pos = (dir > 0) ? 0 : line.length;\n      }\n    }\n\n    /**\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Pos} cur The position to start from.\n     * @param {int} repeat Number of words to move past.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} wordEnd True to move to end of word. False to move to\n     *     beginning of word.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only alphabet characters count as part of the word.\n     * @return {Cursor} The position the cursor should move to.\n     */\n    function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n      var curStart = copyCursor(cur);\n      var words = [];\n      if (forward && !wordEnd || !forward && wordEnd) {\n        repeat++;\n      }\n      // For 'e', empty lines are not considered words, go figure.\n      var emptyLineIsWord = !(forward && wordEnd);\n      for (var i = 0; i < repeat; i++) {\n        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n        if (!word) {\n          var eodCh = lineLength(cm, cm.lastLine());\n          words.push(forward\n              ? {line: cm.lastLine(), from: eodCh, to: eodCh}\n              : {line: 0, from: 0, to: 0});\n          break;\n        }\n        words.push(word);\n        cur = Pos(word.line, forward ? (word.to - 1) : word.from);\n      }\n      var shortCircuit = words.length != repeat;\n      var firstWord = words[0];\n      var lastWord = words.pop();\n      if (forward && !wordEnd) {\n        // w\n        if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return Pos(lastWord.line, lastWord.from);\n      } else if (forward && wordEnd) {\n        return Pos(lastWord.line, lastWord.to - 1);\n      } else if (!forward && wordEnd) {\n        // ge\n        if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return Pos(lastWord.line, lastWord.to);\n      } else {\n        // b\n        return Pos(lastWord.line, lastWord.from);\n      }\n    }\n\n    function moveToCharacter(cm, repeat, forward, character) {\n      var cur = cm.getCursor();\n      var start = cur.ch;\n      var idx;\n      for (var i = 0; i < repeat; i ++) {\n        var line = cm.getLine(cur.line);\n        idx = charIdxInLine(start, line, character, forward, true);\n        if (idx == -1) {\n          return null;\n        }\n        start = idx;\n      }\n      return Pos(cm.getCursor().line, idx);\n    }\n\n    function moveToColumn(cm, repeat) {\n      // repeat is always >= 1, so repeat - 1 always corresponds\n      // to the column we want to go to.\n      var line = cm.getCursor().line;\n      return clipCursorToContent(cm, Pos(line, repeat - 1));\n    }\n\n    function updateMark(cm, vim, markName, pos) {\n      if (!inArray(markName, validMarks)) {\n        return;\n      }\n      if (vim.marks[markName]) {\n        vim.marks[markName].clear();\n      }\n      vim.marks[markName] = cm.setBookmark(pos);\n    }\n\n    function charIdxInLine(start, line, character, forward, includeChar) {\n      // Search for char in line.\n      // motion_options: {forward, includeChar}\n      // If includeChar = true, include it too.\n      // If forward = true, search forward, else search backwards.\n      // If char is not found on this line, do nothing\n      var idx;\n      if (forward) {\n        idx = line.indexOf(character, start + 1);\n        if (idx != -1 && !includeChar) {\n          idx -= 1;\n        }\n      } else {\n        idx = line.lastIndexOf(character, start - 1);\n        if (idx != -1 && !includeChar) {\n          idx += 1;\n        }\n      }\n      return idx;\n    }\n\n    function findParagraph(cm, head, repeat, dir, inclusive) {\n      var line = head.line;\n      var min = cm.firstLine();\n      var max = cm.lastLine();\n      var start, end, i = line;\n      function isEmpty(i) { return !cm.getLine(i); }\n      function isBoundary(i, dir, any) {\n        if (any) { return isEmpty(i) != isEmpty(i + dir); }\n        return !isEmpty(i) && isEmpty(i + dir);\n      }\n      if (dir) {\n        while (min <= i && i <= max && repeat > 0) {\n          if (isBoundary(i, dir)) { repeat--; }\n          i += dir;\n        }\n        return new Pos(i, 0);\n      }\n\n      var vim = cm.state.vim;\n      if (vim.visualLine && isBoundary(line, 1, true)) {\n        var anchor = vim.sel.anchor;\n        if (isBoundary(anchor.line, -1, true)) {\n          if (!inclusive || anchor.line != line) {\n            line += 1;\n          }\n        }\n      }\n      var startState = isEmpty(line);\n      for (i = line; i <= max && repeat; i++) {\n        if (isBoundary(i, 1, true)) {\n          if (!inclusive || isEmpty(i) != startState) {\n            repeat--;\n          }\n        }\n      }\n      end = new Pos(i, 0);\n      // select boundary before paragraph for the last one\n      if (i > max && !startState) { startState = true; }\n      else { inclusive = false; }\n      for (i = line; i > min; i--) {\n        if (!inclusive || isEmpty(i) == startState || i == line) {\n          if (isBoundary(i, -1, true)) { break; }\n        }\n      }\n      start = new Pos(i, 0);\n      return { start: start, end: end };\n    }\n\n    function findSentence(cm, cur, repeat, dir) {\n\n      /*\n        Takes an index object\n        {\n          line: the line string,\n          ln: line number,\n          pos: index in line,\n          dir: direction of traversal (-1 or 1)\n        }\n        and modifies the line, ln, and pos members to represent the\n        next valid position or sets them to null if there are\n        no more valid positions.\n       */\n      function nextChar(cm, idx) {\n        if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {\n          idx.ln += idx.dir;\n          if (!isLine(cm, idx.ln)) {\n            idx.line = null;\n            idx.ln = null;\n            idx.pos = null;\n            return;\n          }\n          idx.line = cm.getLine(idx.ln);\n          idx.pos = (idx.dir > 0) ? 0 : idx.line.length - 1;\n        }\n        else {\n          idx.pos += idx.dir;\n        }\n      }\n\n      /*\n        Performs one iteration of traversal in forward direction\n        Returns an index object of the new location\n       */\n      function forward(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var stop = (line === \"\");\n\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir,\n        }\n\n        var last_valid = {\n          ln: curr.ln,\n          pos: curr.pos,\n        }\n\n        var skip_empty_lines = (curr.line === \"\");\n\n        // Move one step to skip character we start on\n        nextChar(cm, curr);\n\n        while (curr.line !== null) {\n          last_valid.ln = curr.ln;\n          last_valid.pos = curr.pos;\n\n          if (curr.line === \"\" && !skip_empty_lines) {\n            return { ln: curr.ln, pos: curr.pos, };\n          }\n          else if (stop && curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            return { ln: curr.ln, pos: curr.pos, };\n          }\n          else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n            && !stop\n            && (curr.pos === curr.line.length - 1\n              || isWhiteSpaceString(curr.line[curr.pos + 1]))) {\n            stop = true;\n          }\n\n          nextChar(cm, curr);\n        }\n\n        /*\n          Set the position to the last non whitespace character on the last\n          valid line in the case that we reach the end of the document.\n        */\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for(var i = line.length - 1; i >= 0; --i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n\n        return last_valid;\n\n      }\n\n      /*\n        Performs one iteration of traversal in reverse direction\n        Returns an index object of the new location\n       */\n      function reverse(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir,\n        }\n\n        var last_valid = {\n          ln: curr.ln,\n          pos: null,\n        };\n\n        var skip_empty_lines = (curr.line === \"\");\n\n        // Move one step to skip character we start on\n        nextChar(cm, curr);\n\n        while (curr.line !== null) {\n\n          if (curr.line === \"\" && !skip_empty_lines) {\n            if (last_valid.pos !== null) {\n              return last_valid;\n            }\n            else {\n              return { ln: curr.ln, pos: curr.pos };\n            }\n          }\n          else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n              && last_valid.pos !== null\n              && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {\n            return last_valid;\n          }\n          else if (curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            skip_empty_lines = false;\n            last_valid = { ln: curr.ln, pos: curr.pos }\n          }\n\n          nextChar(cm, curr);\n        }\n\n        /*\n          Set the position to the first non whitespace character on the last\n          valid line in the case that we reach the beginning of the document.\n        */\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for(var i = 0; i < line.length; ++i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n        return last_valid;\n      }\n\n      var curr_index = {\n        ln: cur.line,\n        pos: cur.ch,\n      };\n\n      while (repeat > 0) {\n        if (dir < 0) {\n          curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        else {\n          curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        repeat--;\n      }\n\n      return Pos(curr_index.ln, curr_index.pos);\n    }\n\n    // TODO: perhaps this finagling of start and end positions belonds\n    // in codemirror/replaceRange?\n    function selectCompanionObject(cm, head, symb, inclusive) {\n      var cur = head, start, end;\n\n      var bracketRegexp = ({\n        '(': /[()]/, ')': /[()]/,\n        '[': /[[\\]]/, ']': /[[\\]]/,\n        '{': /[{}]/, '}': /[{}]/,\n        '<': /[<>]/, '>': /[<>]/})[symb];\n      var openSym = ({\n        '(': '(', ')': '(',\n        '[': '[', ']': '[',\n        '{': '{', '}': '{',\n        '<': '<', '>': '<'})[symb];\n      var curChar = cm.getLine(cur.line).charAt(cur.ch);\n      // Due to the behavior of scanForBracket, we need to add an offset if the\n      // cursor is on a matching open bracket.\n      var offset = curChar === openSym ? 1 : 0;\n\n      start = cm.scanForBracket(Pos(cur.line, cur.ch + offset), -1, undefined, {'bracketRegex': bracketRegexp});\n      end = cm.scanForBracket(Pos(cur.line, cur.ch + offset), 1, undefined, {'bracketRegex': bracketRegexp});\n\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      start = start.pos;\n      end = end.pos;\n\n      if ((start.line == end.line && start.ch > end.ch)\n          || (start.line > end.line)) {\n        var tmp = start;\n        start = end;\n        end = tmp;\n      }\n\n      if (inclusive) {\n        end.ch += 1;\n      } else {\n        start.ch += 1;\n      }\n\n      return { start: start, end: end };\n    }\n\n    // Takes in a symbol and a cursor and tries to simulate text objects that\n    // have identical opening and closing symbols\n    // TODO support across multiple lines\n    function findBeginningAndEnd(cm, head, symb, inclusive) {\n      var cur = copyCursor(head);\n      var line = cm.getLine(cur.line);\n      var chars = line.split('');\n      var start, end, i, len;\n      var firstIndex = chars.indexOf(symb);\n\n      // the decision tree is to always look backwards for the beginning first,\n      // but if the cursor is in front of the first instance of the symb,\n      // then move the cursor forward\n      if (cur.ch < firstIndex) {\n        cur.ch = firstIndex;\n        // Why is this line even here???\n        // cm.setCursor(cur.line, firstIndex+1);\n      }\n      // otherwise if the cursor is currently on the closing symbol\n      else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n        end = cur.ch; // assign end to the current cursor\n        --cur.ch; // make sure to look backwards\n      }\n\n      // if we're currently on the symbol, we've got a start\n      if (chars[cur.ch] == symb && !end) {\n        start = cur.ch + 1; // assign start to ahead of the cursor\n      } else {\n        // go backwards to find the start\n        for (i = cur.ch; i > -1 && !start; i--) {\n          if (chars[i] == symb) {\n            start = i + 1;\n          }\n        }\n      }\n\n      // look forwards for the end symbol\n      if (start && !end) {\n        for (i = start, len = chars.length; i < len && !end; i++) {\n          if (chars[i] == symb) {\n            end = i;\n          }\n        }\n      }\n\n      // nothing found\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      // include the symbols\n      if (inclusive) {\n        --start; ++end;\n      }\n\n      return {\n        start: Pos(cur.line, start),\n        end: Pos(cur.line, end)\n      };\n    }\n\n    // Search functions\n    defineOption('pcre', true, 'boolean');\n    function SearchState() {}\n    SearchState.prototype = {\n      getQuery: function() {\n        return vimGlobalState.query;\n      },\n      setQuery: function(query) {\n        vimGlobalState.query = query;\n      },\n      getOverlay: function() {\n        return this.searchOverlay;\n      },\n      setOverlay: function(overlay) {\n        this.searchOverlay = overlay;\n      },\n      isReversed: function() {\n        return vimGlobalState.isReversed;\n      },\n      setReversed: function(reversed) {\n        vimGlobalState.isReversed = reversed;\n      },\n      getScrollbarAnnotate: function() {\n        return this.annotate;\n      },\n      setScrollbarAnnotate: function(annotate) {\n        this.annotate = annotate;\n      }\n    };\n    function getSearchState(cm) {\n      var vim = cm.state.vim;\n      return vim.searchState_ || (vim.searchState_ = new SearchState());\n    }\n    function dialog(cm, template, shortText, onClose, options) {\n      if (cm.openDialog) {\n        cm.openDialog(template, onClose, { bottom: true, value: options.value,\n            onKeyDown: options.onKeyDown, onKeyUp: options.onKeyUp,\n            selectValueOnOpen: false});\n      }\n      else {\n        onClose(prompt(shortText, ''));\n      }\n    }\n    function splitBySlash(argString) {\n      return splitBySeparator(argString, '/');\n    }\n\n    function findUnescapedSlashes(argString) {\n      return findUnescapedSeparators(argString, '/');\n    }\n\n    function splitBySeparator(argString, separator) {\n      var slashes = findUnescapedSeparators(argString, separator) || [];\n      if (!slashes.length) return [];\n      var tokens = [];\n      // in case of strings like foo/bar\n      if (slashes[0] !== 0) return;\n      for (var i = 0; i < slashes.length; i++) {\n        if (typeof slashes[i] == 'number')\n          tokens.push(argString.substring(slashes[i] + 1, slashes[i+1]));\n      }\n      return tokens;\n    }\n\n    function findUnescapedSeparators(str, separator) {\n      if (!separator)\n        separator = '/';\n\n      var escapeNextChar = false;\n      var slashes = [];\n      for (var i = 0; i < str.length; i++) {\n        var c = str.charAt(i);\n        if (!escapeNextChar && c == separator) {\n          slashes.push(i);\n        }\n        escapeNextChar = !escapeNextChar && (c == '\\\\');\n      }\n      return slashes;\n    }\n\n    // Translates a search string from ex (vim) syntax into javascript form.\n    function translateRegex(str) {\n      // When these match, add a '\\' if unescaped or remove one if escaped.\n      var specials = '|(){';\n      // Remove, but never add, a '\\' for these.\n      var unescape = '}';\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        var specialComesNext = (n && specials.indexOf(n) != -1);\n        if (escapeNextChar) {\n          if (c !== '\\\\' || !specialComesNext) {\n            out.push(c);\n          }\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            // Treat the unescape list as special for removing, but not adding '\\'.\n            if (n && unescape.indexOf(n) != -1) {\n              specialComesNext = true;\n            }\n            // Not passing this test means removing a '\\'.\n            if (!specialComesNext || n === '\\\\') {\n              out.push(c);\n            }\n          } else {\n            out.push(c);\n            if (specialComesNext && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Translates the replace part of a search and replace from ex (vim) syntax into\n    // javascript form.  Similar to translateRegex, but additionally fixes back references\n    // (translates '\\[0..9]' to '$[0..9]') and follows different rules for escaping '$'.\n    var charUnescapes = {'\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t'};\n    function translateRegexReplace(str) {\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        if (charUnescapes[c + n]) {\n          out.push(charUnescapes[c+n]);\n          i++;\n        } else if (escapeNextChar) {\n          // At any point in the loop, escapeNextChar is true if the previous\n          // character was a '\\' and was not escaped.\n          out.push(c);\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            if ((isNumber(n) || n === '$')) {\n              out.push('$');\n            } else if (n !== '/' && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          } else {\n            if (c === '$') {\n              out.push('$');\n            }\n            out.push(c);\n            if (n === '/') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Unescape \\ and / in the replace part, for PCRE mode.\n    var unescapes = {'\\\\/': '/', '\\\\\\\\': '\\\\', '\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t'};\n    function unescapeRegexReplace(str) {\n      var stream = new CodeMirror.StringStream(str);\n      var output = [];\n      while (!stream.eol()) {\n        // Search for \\.\n        while (stream.peek() && stream.peek() != '\\\\') {\n          output.push(stream.next());\n        }\n        var matched = false;\n        for (var matcher in unescapes) {\n          if (stream.match(matcher, true)) {\n            matched = true;\n            output.push(unescapes[matcher]);\n            break;\n          }\n        }\n        if (!matched) {\n          // Don't change anything\n          output.push(stream.next());\n        }\n      }\n      return output.join('');\n    }\n\n    /**\n     * Extract the regular expression from the query and return a Regexp object.\n     * Returns null if the query is blank.\n     * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.\n     * If smartCase is passed in, and the query contains upper case letters,\n     *   then ignoreCase is overridden, and the 'i' flag will not be set.\n     * If the query contains the /i in the flag part of the regular expression,\n     *   then both ignoreCase and smartCase are ignored, and 'i' will be passed\n     *   through to the Regex object.\n     */\n    function parseQuery(query, ignoreCase, smartCase) {\n      // First update the last search register\n      var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n      lastSearchRegister.setText(query);\n      // Check if the query is already a regex.\n      if (query instanceof RegExp) { return query; }\n      // First try to extract regex + flags from the input. If no flags found,\n      // extract just the regex. IE does not accept flags directly defined in\n      // the regex string in the form /regex/flags\n      var slashes = findUnescapedSlashes(query);\n      var regexPart;\n      var forceIgnoreCase;\n      if (!slashes.length) {\n        // Query looks like 'regexp'\n        regexPart = query;\n      } else {\n        // Query looks like 'regexp/...'\n        regexPart = query.substring(0, slashes[0]);\n        var flagsPart = query.substring(slashes[0]);\n        forceIgnoreCase = (flagsPart.indexOf('i') != -1);\n      }\n      if (!regexPart) {\n        return null;\n      }\n      if (!getOption('pcre')) {\n        regexPart = translateRegex(regexPart);\n      }\n      if (smartCase) {\n        ignoreCase = (/^[^A-Z]*$/).test(regexPart);\n      }\n      var regexp = new RegExp(regexPart,\n          (ignoreCase || forceIgnoreCase) ? 'i' : undefined);\n      return regexp;\n    }\n    function showConfirm(cm, text) {\n      if (cm.openNotification) {\n        cm.openNotification('<span style=\"color: red\">' + text + '</span>',\n                            {bottom: true, duration: 5000});\n      } else {\n        alert(text);\n      }\n    }\n    function makePrompt(prefix, desc) {\n      var raw = '<span style=\"font-family: monospace; white-space: pre\">' +\n          (prefix || \"\") + '<input type=\"text\"></span>';\n      if (desc)\n        raw += ' <span style=\"color: #888\">' + desc + '</span>';\n      return raw;\n    }\n    var searchPromptDesc = '(Javascript regexp)';\n    function showPrompt(cm, options) {\n      var shortText = (options.prefix || '') + ' ' + (options.desc || '');\n      var prompt = makePrompt(options.prefix, options.desc);\n      dialog(cm, prompt, shortText, options.onClose, options);\n    }\n    function regexEqual(r1, r2) {\n      if (r1 instanceof RegExp && r2 instanceof RegExp) {\n          var props = ['global', 'multiline', 'ignoreCase', 'source'];\n          for (var i = 0; i < props.length; i++) {\n              var prop = props[i];\n              if (r1[prop] !== r2[prop]) {\n                  return false;\n              }\n          }\n          return true;\n      }\n      return false;\n    }\n    // Returns true if the query is valid.\n    function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n      if (!rawQuery) {\n        return;\n      }\n      var state = getSearchState(cm);\n      var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n      if (!query) {\n        return;\n      }\n      highlightSearchMatches(cm, query);\n      if (regexEqual(query, state.getQuery())) {\n        return query;\n      }\n      state.setQuery(query);\n      return query;\n    }\n    function searchOverlay(query) {\n      if (query.source.charAt(0) == '^') {\n        var matchSol = true;\n      }\n      return {\n        token: function(stream) {\n          if (matchSol && !stream.sol()) {\n            stream.skipToEnd();\n            return;\n          }\n          var match = stream.match(query, false);\n          if (match) {\n            if (match[0].length == 0) {\n              // Matched empty string, skip to next.\n              stream.next();\n              return 'searching';\n            }\n            if (!stream.sol()) {\n              // Backtrack 1 to match \\b\n              stream.backUp(1);\n              if (!query.exec(stream.next() + match[0])) {\n                stream.next();\n                return null;\n              }\n            }\n            stream.match(query);\n            return 'searching';\n          }\n          while (!stream.eol()) {\n            stream.next();\n            if (stream.match(query, false)) break;\n          }\n        },\n        query: query\n      };\n    }\n    function highlightSearchMatches(cm, query) {\n      var searchState = getSearchState(cm);\n      var overlay = searchState.getOverlay();\n      if (!overlay || query != overlay.query) {\n        if (overlay) {\n          cm.removeOverlay(overlay);\n        }\n        overlay = searchOverlay(query);\n        cm.addOverlay(overlay);\n        if (cm.showMatchesOnScrollbar) {\n          if (searchState.getScrollbarAnnotate()) {\n            searchState.getScrollbarAnnotate().clear();\n          }\n          searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n        }\n        searchState.setOverlay(overlay);\n      }\n    }\n    function findNext(cm, prev, query, repeat) {\n      if (repeat === undefined) { repeat = 1; }\n      return cm.operation(function() {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n        for (var i = 0; i < repeat; i++) {\n          var found = cursor.find(prev);\n          if (i == 0 && found && cursorEqual(cursor.from(), pos)) { found = cursor.find(prev); }\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query,\n                (prev) ? Pos(cm.lastLine()) : Pos(cm.firstLine(), 0) );\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n        return cursor.from();\n      });\n    }\n    function clearSearchHighlight(cm) {\n      var state = getSearchState(cm);\n      cm.removeOverlay(getSearchState(cm).getOverlay());\n      state.setOverlay(null);\n      if (state.getScrollbarAnnotate()) {\n        state.getScrollbarAnnotate().clear();\n        state.setScrollbarAnnotate(null);\n      }\n    }\n    /**\n     * Check if pos is in the specified range, INCLUSIVE.\n     * Range can be specified with 1 or 2 arguments.\n     * If the first range argument is an array, treat it as an array of line\n     * numbers. Match pos against any of the lines.\n     * If the first range argument is a number,\n     *   if there is only 1 range argument, check if pos has the same line\n     *       number\n     *   if there are 2 range arguments, then check if pos is in between the two\n     *       range arguments.\n     */\n    function isInRange(pos, start, end) {\n      if (typeof pos != 'number') {\n        // Assume it is a cursor position. Get the line number.\n        pos = pos.line;\n      }\n      if (start instanceof Array) {\n        return inArray(pos, start);\n      } else {\n        if (end) {\n          return (pos >= start && pos <= end);\n        } else {\n          return pos == start;\n        }\n      }\n    }\n    function getUserVisibleLines(cm) {\n      var scrollInfo = cm.getScrollInfo();\n      var occludeToleranceTop = 6;\n      var occludeToleranceBottom = 10;\n      var from = cm.coordsChar({left:0, top: occludeToleranceTop + scrollInfo.top}, 'local');\n      var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;\n      var to = cm.coordsChar({left:0, top: bottomY}, 'local');\n      return {top: from.line, bottom: to.line};\n    }\n\n    function getMarkPos(cm, vim, markName) {\n      if (markName == '\\'') {\n        var history = cm.doc.history.done;\n        var event = history[history.length - 2];\n        return event && event.ranges && event.ranges[0].head;\n      } else if (markName == '.') {\n        if (cm.doc.history.lastModTime == 0) {\n          return  // If no changes, bail out; don't bother to copy or reverse history array.\n        } else {\n          var changeHistory = cm.doc.history.done.filter(function(el){ if (el.changes !== undefined) { return el } });\n          changeHistory.reverse();\n          var lastEditPos = changeHistory[0].changes[0].to;\n        }\n        return lastEditPos;\n      }\n\n      var mark = vim.marks[markName];\n      return mark && mark.find();\n    }\n\n    var ExCommandDispatcher = function() {\n      this.buildCommandMap_();\n    };\n    ExCommandDispatcher.prototype = {\n      processCommand: function(cm, input, opt_params) {\n        var that = this;\n        cm.operation(function () {\n          cm.curOp.isVimOp = true;\n          that._processCommand(cm, input, opt_params);\n        });\n      },\n      _processCommand: function(cm, input, opt_params) {\n        var vim = cm.state.vim;\n        var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n        var previousCommand = commandHistoryRegister.toString();\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        var inputStream = new CodeMirror.StringStream(input);\n        // update \": with the latest command whether valid or invalid\n        commandHistoryRegister.setText(input);\n        var params = opt_params || {};\n        params.input = input;\n        try {\n          this.parseInput_(cm, inputStream, params);\n        } catch(e) {\n          showConfirm(cm, e);\n          throw e;\n        }\n        var command;\n        var commandName;\n        if (!params.commandName) {\n          // If only a line range is defined, move to the line.\n          if (params.line !== undefined) {\n            commandName = 'move';\n          }\n        } else {\n          command = this.matchCommand_(params.commandName);\n          if (command) {\n            commandName = command.name;\n            if (command.excludeFromCommandHistory) {\n              commandHistoryRegister.setText(previousCommand);\n            }\n            this.parseCommandArgs_(inputStream, params, command);\n            if (command.type == 'exToKey') {\n              // Handle Ex to Key mapping.\n              for (var i = 0; i < command.toKeys.length; i++) {\n                CodeMirror.Vim.handleKey(cm, command.toKeys[i], 'mapping');\n              }\n              return;\n            } else if (command.type == 'exToEx') {\n              // Handle Ex to Ex mapping.\n              this.processCommand(cm, command.toInput);\n              return;\n            }\n          }\n        }\n        if (!commandName) {\n          showConfirm(cm, 'Not an editor command \":' + input + '\"');\n          return;\n        }\n        try {\n          exCommands[commandName](cm, params);\n          // Possibly asynchronous commands (e.g. substitute, which might have a\n          // user confirmation), are responsible for calling the callback when\n          // done. All others have it taken care of for them here.\n          if ((!command || !command.possiblyAsync) && params.callback) {\n            params.callback();\n          }\n        } catch(e) {\n          showConfirm(cm, e);\n          throw e;\n        }\n      },\n      parseInput_: function(cm, inputStream, result) {\n        inputStream.eatWhile(':');\n        // Parse range.\n        if (inputStream.eat('%')) {\n          result.line = cm.firstLine();\n          result.lineEnd = cm.lastLine();\n        } else {\n          result.line = this.parseLineSpec_(cm, inputStream);\n          if (result.line !== undefined && inputStream.eat(',')) {\n            result.lineEnd = this.parseLineSpec_(cm, inputStream);\n          }\n        }\n\n        // Parse command name.\n        var commandMatch = inputStream.match(/^(\\w+)/);\n        if (commandMatch) {\n          result.commandName = commandMatch[1];\n        } else {\n          result.commandName = inputStream.match(/.*/)[0];\n        }\n\n        return result;\n      },\n      parseLineSpec_: function(cm, inputStream) {\n        var numberMatch = inputStream.match(/^(\\d+)/);\n        if (numberMatch) {\n          // Absolute line number plus offset (N+M or N-M) is probably a typo,\n          // not something the user actually wanted. (NB: vim does allow this.)\n          return parseInt(numberMatch[1], 10) - 1;\n        }\n        switch (inputStream.next()) {\n          case '.':\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          case '$':\n            return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n          case '\\'':\n            var markName = inputStream.next();\n            var markPos = getMarkPos(cm, cm.state.vim, markName);\n            if (!markPos) throw new Error('Mark not set');\n            return this.parseLineSpecOffset_(inputStream, markPos.line);\n          case '-':\n          case '+':\n            inputStream.backUp(1);\n            // Offset is relative to current line if not otherwise specified.\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          default:\n            inputStream.backUp(1);\n            return undefined;\n        }\n      },\n      parseLineSpecOffset_: function(inputStream, line) {\n        var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n        if (offsetMatch) {\n          var offset = parseInt(offsetMatch[2], 10);\n          if (offsetMatch[1] == \"-\") {\n            line -= offset;\n          } else {\n            line += offset;\n          }\n        }\n        return line;\n      },\n      parseCommandArgs_: function(inputStream, params, command) {\n        if (inputStream.eol()) {\n          return;\n        }\n        params.argString = inputStream.match(/.*/)[0];\n        // Parse command-line arguments\n        var delim = command.argDelimiter || /\\s+/;\n        var args = trim(params.argString).split(delim);\n        if (args.length && args[0]) {\n          params.args = args;\n        }\n      },\n      matchCommand_: function(commandName) {\n        // Return the command in the command map that matches the shortest\n        // prefix of the passed in command name. The match is guaranteed to be\n        // unambiguous if the defaultExCommandMap's shortNames are set up\n        // correctly. (see @code{defaultExCommandMap}).\n        for (var i = commandName.length; i > 0; i--) {\n          var prefix = commandName.substring(0, i);\n          if (this.commandMap_[prefix]) {\n            var command = this.commandMap_[prefix];\n            if (command.name.indexOf(commandName) === 0) {\n              return command;\n            }\n          }\n        }\n        return null;\n      },\n      buildCommandMap_: function() {\n        this.commandMap_ = {};\n        for (var i = 0; i < defaultExCommandMap.length; i++) {\n          var command = defaultExCommandMap[i];\n          var key = command.shortName || command.name;\n          this.commandMap_[key] = command;\n        }\n      },\n      map: function(lhs, rhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Ex to Ex mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToEx',\n              toInput: rhs.substring(1),\n              user: true\n            };\n          } else {\n            // Ex to key mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToKey',\n              toKeys: rhs,\n              user: true\n            };\n          }\n        } else {\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Key to Ex mapping.\n            var mapping = {\n              keys: lhs,\n              type: 'keyToEx',\n              exArgs: { input: rhs.substring(1) }\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          } else {\n            // Key to key mapping\n            var mapping = {\n              keys: lhs,\n              type: 'keyToKey',\n              toKeys: rhs\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          }\n        }\n      },\n      unmap: function(lhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          // Ex to Ex or Ex to key mapping\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n            delete this.commandMap_[commandName];\n            return;\n          }\n        } else {\n          // Key to Ex or key to key mapping\n          var keys = lhs;\n          for (var i = 0; i < defaultKeymap.length; i++) {\n            if (keys == defaultKeymap[i].keys\n                && defaultKeymap[i].context === ctx) {\n              defaultKeymap.splice(i, 1);\n              return;\n            }\n          }\n        }\n        throw Error('No such mapping.');\n      }\n    };\n\n    var exCommands = {\n      colorscheme: function(cm, params) {\n        if (!params.args || params.args.length < 1) {\n          showConfirm(cm, cm.getOption('theme'));\n          return;\n        }\n        cm.setOption('theme', params.args[0]);\n      },\n      map: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 2) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);\n      },\n      imap: function(cm, params) { this.map(cm, params, 'insert'); },\n      nmap: function(cm, params) { this.map(cm, params, 'normal'); },\n      vmap: function(cm, params) { this.map(cm, params, 'visual'); },\n      unmap: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'No such mapping: ' + params.input);\n          }\n          return;\n        }\n        exCommandDispatcher.unmap(mapArgs[0], ctx);\n      },\n      move: function(cm, params) {\n        commandDispatcher.processCommand(cm, cm.state.vim, {\n            type: 'motion',\n            motion: 'moveToLineOrEdgeOfDocument',\n            motionArgs: { forward: false, explicitRepeat: true,\n              linewise: true },\n            repeatOverride: params.line+1});\n      },\n      set: function(cm, params) {\n        var setArgs = params.args;\n        // Options passed through to the setOption/getOption calls. May be passed in by the\n        // local/global versions of the set command\n        var setCfg = params.setCfg || {};\n        if (!setArgs || setArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        var expr = setArgs[0].split('=');\n        var optionName = expr[0];\n        var value = expr[1];\n        var forceGet = false;\n\n        if (optionName.charAt(optionName.length - 1) == '?') {\n          // If post-fixed with ?, then the set is actually a get.\n          if (value) { throw Error('Trailing characters: ' + params.argString); }\n          optionName = optionName.substring(0, optionName.length - 1);\n          forceGet = true;\n        }\n        if (value === undefined && optionName.substring(0, 2) == 'no') {\n          // To set boolean options to false, the option name is prefixed with\n          // 'no'.\n          optionName = optionName.substring(2);\n          value = false;\n        }\n\n        var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n        if (optionIsBoolean && value == undefined) {\n          // Calling set with a boolean option sets it to true.\n          value = true;\n        }\n        // If no value is provided, then we assume this is a get.\n        if (!optionIsBoolean && value === undefined || forceGet) {\n          var oldValue = getOption(optionName, cm, setCfg);\n          if (oldValue instanceof Error) {\n            showConfirm(cm, oldValue.message);\n          } else if (oldValue === true || oldValue === false) {\n            showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n          } else {\n            showConfirm(cm, '  ' + optionName + '=' + oldValue);\n          }\n        } else {\n          var setOptionReturn = setOption(optionName, value, cm, setCfg);\n          if (setOptionReturn instanceof Error) {\n            showConfirm(cm, setOptionReturn.message);\n          }\n        }\n      },\n      setlocal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'local'};\n        this.set(cm, params);\n      },\n      setglobal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'global'};\n        this.set(cm, params);\n      },\n      registers: function(cm, params) {\n        var regArgs = params.args;\n        var registers = vimGlobalState.registerController.registers;\n        var regInfo = '----------Registers----------<br><br>';\n        if (!regArgs) {\n          for (var registerName in registers) {\n            var text = registers[registerName].toString();\n            if (text.length) {\n              regInfo += '\"' + registerName + '    ' + text + '<br>';\n            }\n          }\n        } else {\n          var registerName;\n          regArgs = regArgs.join('');\n          for (var i = 0; i < regArgs.length; i++) {\n            registerName = regArgs.charAt(i);\n            if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n              continue;\n            }\n            var register = registers[registerName] || new Register();\n            regInfo += '\"' + registerName + '    ' + register.toString() + '<br>';\n          }\n        }\n        showConfirm(cm, regInfo);\n      },\n      sort: function(cm, params) {\n        var reverse, ignoreCase, unique, number, pattern;\n        function parseArgs() {\n          if (params.argString) {\n            var args = new CodeMirror.StringStream(params.argString);\n            if (args.eat('!')) { reverse = true; }\n            if (args.eol()) { return; }\n            if (!args.eatSpace()) { return 'Invalid arguments'; }\n            var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n            if (!opts && !args.eol()) { return 'Invalid arguments'; }\n            if (opts[1]) {\n              ignoreCase = opts[1].indexOf('i') != -1;\n              unique = opts[1].indexOf('u') != -1;\n              var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;\n              var hex = opts[1].indexOf('x') != -1 && 1;\n              var octal = opts[1].indexOf('o') != -1 && 1;\n              if (decimal + hex + octal > 1) { return 'Invalid arguments'; }\n              number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n            }\n            if (opts[2]) {\n              pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n            }\n          }\n        }\n        var err = parseArgs();\n        if (err) {\n          showConfirm(cm, err + ': ' + params.argString);\n          return;\n        }\n        var lineStart = params.line || cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        if (lineStart == lineEnd) { return; }\n        var curStart = Pos(lineStart, 0);\n        var curEnd = Pos(lineEnd, lineLength(cm, lineEnd));\n        var text = cm.getRange(curStart, curEnd).split('\\n');\n        var numberRegex = pattern ? pattern :\n           (number == 'decimal') ? /(-?)([\\d]+)/ :\n           (number == 'hex') ? /(-?)(?:0x)?([0-9a-f]+)/i :\n           (number == 'octal') ? /([0-7]+)/ : null;\n        var radix = (number == 'decimal') ? 10 : (number == 'hex') ? 16 : (number == 'octal') ? 8 : null;\n        var numPart = [], textPart = [];\n        if (number || pattern) {\n          for (var i = 0; i < text.length; i++) {\n            var matchPart = pattern ? text[i].match(pattern) : null;\n            if (matchPart && matchPart[0] != '') {\n              numPart.push(matchPart);\n            } else if (!pattern && numberRegex.exec(text[i])) {\n              numPart.push(text[i]);\n            } else {\n              textPart.push(text[i]);\n            }\n          }\n        } else {\n          textPart = text;\n        }\n        function compareFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a = a.toLowerCase(); b = b.toLowerCase(); }\n          var anum = number && numberRegex.exec(a);\n          var bnum = number && numberRegex.exec(b);\n          if (!anum) { return a < b ? -1 : 1; }\n          anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n          bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n          return anum - bnum;\n        }\n        function comparePatternFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a[0] = a[0].toLowerCase(); b[0] = b[0].toLowerCase(); }\n          return (a[0] < b[0]) ? -1 : 1;\n        }\n        numPart.sort(pattern ? comparePatternFn : compareFn);\n        if (pattern) {\n          for (var i = 0; i < numPart.length; i++) {\n            numPart[i] = numPart[i].input;\n          }\n        } else if (!number) { textPart.sort(compareFn); }\n        text = (!reverse) ? textPart.concat(numPart) : numPart.concat(textPart);\n        if (unique) { // Remove duplicate lines\n          var textOld = text;\n          var lastLine;\n          text = [];\n          for (var i = 0; i < textOld.length; i++) {\n            if (textOld[i] != lastLine) {\n              text.push(textOld[i]);\n            }\n            lastLine = textOld[i];\n          }\n        }\n        cm.replaceRange(text.join('\\n'), curStart, curEnd);\n      },\n      global: function(cm, params) {\n        // a global command is of the form\n        // :[range]g/pattern/[cmd]\n        // argString holds the string /pattern/[cmd]\n        var argString = params.argString;\n        if (!argString) {\n          showConfirm(cm, 'Regular Expression missing from global');\n          return;\n        }\n        // range is specified here\n        var lineStart = (params.line !== undefined) ? params.line : cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        // get the tokens from argString\n        var tokens = splitBySlash(argString);\n        var regexPart = argString, cmd;\n        if (tokens.length) {\n          regexPart = tokens[0];\n          cmd = tokens.slice(1, tokens.length).join('/');\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise\n          // use the regex part as the new query.\n          try {\n           updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n             true /** smartCase */);\n          } catch (e) {\n           showConfirm(cm, 'Invalid regex: ' + regexPart);\n           return;\n          }\n        }\n        // now that we have the regexPart, search for regex matches in the\n        // specified range of lines\n        var query = getSearchState(cm).getQuery();\n        var matchedLines = [], content = '';\n        for (var i = lineStart; i <= lineEnd; i++) {\n          var matched = query.test(cm.getLine(i));\n          if (matched) {\n            matchedLines.push(i+1);\n            content+= cm.getLine(i) + '<br>';\n          }\n        }\n        // if there is no [cmd], just display the list of matched lines\n        if (!cmd) {\n          showConfirm(cm, content);\n          return;\n        }\n        var index = 0;\n        var nextCommand = function() {\n          if (index < matchedLines.length) {\n            var command = matchedLines[index] + cmd;\n            exCommandDispatcher.processCommand(cm, command, {\n              callback: nextCommand\n            });\n          }\n          index++;\n        };\n        nextCommand();\n      },\n      substitute: function(cm, params) {\n        if (!cm.getSearchCursor) {\n          throw new Error('Search feature not available. Requires searchcursor.js or ' +\n              'any other getSearchCursor implementation.');\n        }\n        var argString = params.argString;\n        var tokens = argString ? splitBySeparator(argString, argString[0]) : [];\n        var regexPart, replacePart = '', trailing, flagsPart, count;\n        var confirm = false; // Whether to confirm each replace.\n        var global = false; // True to replace all instances on a line, false to replace only 1.\n        if (tokens.length) {\n          regexPart = tokens[0];\n          replacePart = tokens[1];\n          if (regexPart && regexPart[regexPart.length - 1] === '$') {\n            regexPart = regexPart.slice(0, regexPart.length - 1) + '\\\\n';\n            replacePart = replacePart ? replacePart + '\\n' : '\\n';\n          }\n          if (replacePart !== undefined) {\n            if (getOption('pcre')) {\n              replacePart = unescapeRegexReplace(replacePart);\n            } else {\n              replacePart = translateRegexReplace(replacePart);\n            }\n            vimGlobalState.lastSubstituteReplacePart = replacePart;\n          }\n          trailing = tokens[2] ? tokens[2].split(' ') : [];\n        } else {\n          // either the argString is empty or its of the form ' hello/world'\n          // actually splitBySlash returns a list of tokens\n          // only if the string starts with a '/'\n          if (argString && argString.length) {\n            showConfirm(cm, 'Substitutions should be of the form ' +\n                ':s/pattern/replace/');\n            return;\n          }\n        }\n        // After the 3rd slash, we can have flags followed by a space followed\n        // by count.\n        if (trailing) {\n          flagsPart = trailing[0];\n          count = parseInt(trailing[1]);\n          if (flagsPart) {\n            if (flagsPart.indexOf('c') != -1) {\n              confirm = true;\n              flagsPart.replace('c', '');\n            }\n            if (flagsPart.indexOf('g') != -1) {\n              global = true;\n              flagsPart.replace('g', '');\n            }\n            regexPart = regexPart.replace(/\\//g, \"\\\\/\") + '/' + flagsPart;\n          }\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise use\n          // the regex part as the new query.\n          try {\n            updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n              true /** smartCase */);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + regexPart);\n            return;\n          }\n        }\n        replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n        if (replacePart === undefined) {\n          showConfirm(cm, 'No previous substitute regular expression');\n          return;\n        }\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        var lineStart = (params.line !== undefined) ? params.line : cm.getCursor().line;\n        var lineEnd = params.lineEnd || lineStart;\n        if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n          lineEnd = Infinity;\n        }\n        if (count) {\n          lineStart = lineEnd;\n          lineEnd = lineStart + count - 1;\n        }\n        var startPos = clipCursorToContent(cm, Pos(lineStart, 0));\n        var cursor = cm.getSearchCursor(query, startPos);\n        doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n      },\n      redo: CodeMirror.commands.redo,\n      undo: CodeMirror.commands.undo,\n      write: function(cm) {\n        if (CodeMirror.commands.save) {\n          // If a save command is defined, call it.\n          CodeMirror.commands.save(cm);\n        } else if (cm.save) {\n          // Saves to text area if no save command is defined and cm.save() is available.\n          cm.save();\n        }\n      },\n      nohlsearch: function(cm) {\n        clearSearchHighlight(cm);\n      },\n      yank: function (cm) {\n        var cur = copyCursor(cm.getCursor());\n        var line = cur.line;\n        var lineText = cm.getLine(line);\n        vimGlobalState.registerController.pushText(\n          '0', 'yank', lineText, true, true);\n      },\n      delmarks: function(cm, params) {\n        if (!params.argString || !trim(params.argString)) {\n          showConfirm(cm, 'Argument required');\n          return;\n        }\n\n        var state = cm.state.vim;\n        var stream = new CodeMirror.StringStream(trim(params.argString));\n        while (!stream.eol()) {\n          stream.eatSpace();\n\n          // Record the streams position at the beginning of the loop for use\n          // in error messages.\n          var count = stream.pos;\n\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n            return;\n          }\n\n          var sym = stream.next();\n          // Check if this symbol is part of a range\n          if (stream.match('-', true)) {\n            // This symbol is part of a range.\n\n            // The range must terminate at an alphabetic character.\n            if (!stream.match(/[a-zA-Z]/, false)) {\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n              return;\n            }\n\n            var startMark = sym;\n            var finishMark = stream.next();\n            // The range must terminate at an alphabetic character which\n            // shares the same case as the start of the range.\n            if (isLowerCase(startMark) && isLowerCase(finishMark) ||\n                isUpperCase(startMark) && isUpperCase(finishMark)) {\n              var start = startMark.charCodeAt(0);\n              var finish = finishMark.charCodeAt(0);\n              if (start >= finish) {\n                showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                return;\n              }\n\n              // Because marks are always ASCII values, and we have\n              // determined that they are the same case, we can use\n              // their char codes to iterate through the defined range.\n              for (var j = 0; j <= finish - start; j++) {\n                var mark = String.fromCharCode(start + j);\n                delete state.marks[mark];\n              }\n            } else {\n              showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n              return;\n            }\n          } else {\n            // This symbol is a valid mark, and is not part of a range.\n            delete state.marks[sym];\n          }\n        }\n      }\n    };\n\n    var exCommandDispatcher = new ExCommandDispatcher();\n\n    /**\n    * @param {CodeMirror} cm CodeMirror instance we are in.\n    * @param {boolean} confirm Whether to confirm each replace.\n    * @param {Cursor} lineStart Line to start replacing from.\n    * @param {Cursor} lineEnd Line to stop replacing at.\n    * @param {RegExp} query Query for performing matches with.\n    * @param {string} replaceWith Text to replace matches with. May contain $1,\n    *     $2, etc for replacing captured groups using Javascript replace.\n    * @param {function()} callback A callback for when the replace is done.\n    */\n    function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query,\n        replaceWith, callback) {\n      // Set up all the functions.\n      cm.state.vim.exMode = true;\n      var done = false;\n      var lastPos = searchCursor.from();\n      function replaceAll() {\n        cm.operation(function() {\n          while (!done) {\n            replace();\n            next();\n          }\n          stop();\n        });\n      }\n      function replace() {\n        var text = cm.getRange(searchCursor.from(), searchCursor.to());\n        var newText = text.replace(query, replaceWith);\n        searchCursor.replace(newText);\n      }\n      function next() {\n        // The below only loops to skip over multiple occurrences on the same\n        // line when 'global' is not true.\n        while(searchCursor.findNext() &&\n              isInRange(searchCursor.from(), lineStart, lineEnd)) {\n          if (!global && lastPos && searchCursor.from().line == lastPos.line) {\n            continue;\n          }\n          cm.scrollIntoView(searchCursor.from(), 30);\n          cm.setSelection(searchCursor.from(), searchCursor.to());\n          lastPos = searchCursor.from();\n          done = false;\n          return;\n        }\n        done = true;\n      }\n      function stop(close) {\n        if (close) { close(); }\n        cm.focus();\n        if (lastPos) {\n          cm.setCursor(lastPos);\n          var vim = cm.state.vim;\n          vim.exMode = false;\n          vim.lastHPos = vim.lastHSPos = lastPos.ch;\n        }\n        if (callback) { callback(); }\n      }\n      function onPromptKeyDown(e, _value, close) {\n        // Swallow all keys.\n        CodeMirror.e_stop(e);\n        var keyName = CodeMirror.keyName(e);\n        switch (keyName) {\n          case 'Y':\n            replace(); next(); break;\n          case 'N':\n            next(); break;\n          case 'A':\n            // replaceAll contains a call to close of its own. We don't want it\n            // to fire too early or multiple times.\n            var savedCallback = callback;\n            callback = undefined;\n            cm.operation(replaceAll);\n            callback = savedCallback;\n            break;\n          case 'L':\n            replace();\n            // fall through and exit.\n          case 'Q':\n          case 'Esc':\n          case 'Ctrl-C':\n          case 'Ctrl-[':\n            stop(close);\n            break;\n        }\n        if (done) { stop(close); }\n        return true;\n      }\n\n      // Actually do replace.\n      next();\n      if (done) {\n        showConfirm(cm, 'No matches for ' + query.source);\n        return;\n      }\n      if (!confirm) {\n        replaceAll();\n        if (callback) { callback(); }\n        return;\n      }\n      showPrompt(cm, {\n        prefix: 'replace with <strong>' + replaceWith + '</strong> (y/n/a/q/l)',\n        onKeyDown: onPromptKeyDown\n      });\n    }\n\n    CodeMirror.keyMap.vim = {\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function exitInsertMode(cm) {\n      var vim = cm.state.vim;\n      var macroModeState = vimGlobalState.macroModeState;\n      var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n      var isPlaying = macroModeState.isPlaying;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (!isPlaying) {\n        cm.off('change', onChange);\n        CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n      }\n      if (!isPlaying && vim.insertModeRepeat > 1) {\n        // Perform insert mode repeat for commands like 3,a and 3,o.\n        repeatLastEdit(cm, vim, vim.insertModeRepeat - 1,\n            true /** repeatForInsert */);\n        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n      }\n      delete vim.insertModeRepeat;\n      vim.insertMode = false;\n      cm.setCursor(cm.getCursor().line, cm.getCursor().ch-1);\n      cm.setOption('keyMap', 'vim');\n      cm.setOption('disableInput', true);\n      cm.toggleOverwrite(false); // exit replace mode if we were in it.\n      // update the \". register before exiting insert mode\n      insertModeChangeRegister.setText(lastChange.changes.join(''));\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      if (macroModeState.isRecording) {\n        logInsertModeChange(macroModeState);\n      }\n    }\n\n    function _mapCommand(command) {\n      defaultKeymap.unshift(command);\n    }\n\n    function mapCommand(keys, type, name, args, extra) {\n      var command = {keys: keys, type: type};\n      command[type] = name;\n      command[type + \"Args\"] = args;\n      for (var key in extra)\n        command[key] = extra[key];\n      _mapCommand(command);\n    }\n\n    // The timeout in milliseconds for the two-character ESC keymap should be\n    // adjusted according to your typing speed to prevent false positives.\n    defineOption('insertModeEscKeysTimeout', 200, 'number');\n\n    CodeMirror.keyMap['vim-insert'] = {\n      // TODO: override navigation keys so that Esc will cancel automatic\n      // indentation from o, O, i_<CR>\n      fallthrough: ['default'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    CodeMirror.keyMap['vim-replace'] = {\n      'Backspace': 'goCharLeft',\n      fallthrough: ['vim-insert'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function executeMacroRegister(cm, vim, macroModeState, registerName) {\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (registerName == ':') {\n        // Read-only register containing last Ex command.\n        if (register.keyBuffer[0]) {\n          exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n        }\n        macroModeState.isPlaying = false;\n        return;\n      }\n      var keyBuffer = register.keyBuffer;\n      var imc = 0;\n      macroModeState.isPlaying = true;\n      macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n      for (var i = 0; i < keyBuffer.length; i++) {\n        var text = keyBuffer[i];\n        var match, key;\n        while (text) {\n          // Pull off one command key, which is either a single character\n          // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n          match = (/<\\w+-.+?>|<\\w+>|./).exec(text);\n          key = match[0];\n          text = text.substring(match.index + key.length);\n          CodeMirror.Vim.handleKey(cm, key, 'macro');\n          if (vim.insertMode) {\n            var changes = register.insertModeChanges[imc++].changes;\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes =\n                changes;\n            repeatInsertModeChanges(cm, changes, 1);\n            exitInsertMode(cm);\n          }\n        }\n      }\n      macroModeState.isPlaying = false;\n    }\n\n    function logKey(macroModeState, key) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register) {\n        register.pushText(key);\n      }\n    }\n\n    function logInsertModeChange(macroModeState) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushInsertModeChanges) {\n        register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n      }\n    }\n\n    function logSearchQuery(macroModeState, query) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushSearchQuery) {\n        register.pushSearchQuery(query);\n      }\n    }\n\n    /**\n     * Listens for changes made in insert mode.\n     * Should only be active in insert mode.\n     */\n    function onChange(cm, changeObj) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (!macroModeState.isPlaying) {\n        while(changeObj) {\n          lastChange.expectCursorActivityForChange = true;\n          if (lastChange.ignoreCount > 1) {\n            lastChange.ignoreCount--;\n          } else if (changeObj.origin == '+input' || changeObj.origin == 'paste'\n              || changeObj.origin === undefined /* only in testing */) {\n            var selectionCount = cm.listSelections().length;\n            if (selectionCount > 1)\n              lastChange.ignoreCount = selectionCount;\n            var text = changeObj.text.join('\\n');\n            if (lastChange.maybeReset) {\n              lastChange.changes = [];\n              lastChange.maybeReset = false;\n            }\n            if (text) {\n              if (cm.state.overwrite && !/\\n/.test(text)) {\n                lastChange.changes.push([text]);\n              } else {\n                lastChange.changes.push(text);\n              }\n            }\n          }\n          // Change objects may be chained with next.\n          changeObj = changeObj.next;\n        }\n      }\n    }\n\n    /**\n    * Listens for any kind of cursor activity on CodeMirror.\n    */\n    function onCursorActivity(cm) {\n      var vim = cm.state.vim;\n      if (vim.insertMode) {\n        // Tracking cursor activity in insert mode (for macro support).\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        var lastChange = macroModeState.lastInsertModeChanges;\n        if (lastChange.expectCursorActivityForChange) {\n          lastChange.expectCursorActivityForChange = false;\n        } else {\n          // Cursor moved outside the context of an edit. Reset the change.\n          lastChange.maybeReset = true;\n        }\n      } else if (!cm.curOp.isVimOp) {\n        handleExternalSelection(cm, vim);\n      }\n      if (vim.visualMode) {\n        updateFakeCursor(cm);\n      }\n    }\n    function updateFakeCursor(cm) {\n      var vim = cm.state.vim;\n      var from = clipCursorToContent(cm, copyCursor(vim.sel.head));\n      var to = offsetCursor(from, 0, 1);\n      if (vim.fakeCursor) {\n        vim.fakeCursor.clear();\n      }\n      vim.fakeCursor = cm.markText(from, to, {className: 'cm-animate-fat-cursor'});\n    }\n    function handleExternalSelection(cm, vim) {\n      var anchor = cm.getCursor('anchor');\n      var head = cm.getCursor('head');\n      // Enter or exit visual mode to match mouse selection.\n      if (vim.visualMode && !cm.somethingSelected()) {\n        exitVisualMode(cm, false);\n      } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n        vim.visualMode = true;\n        vim.visualLine = false;\n        CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\"});\n      }\n      if (vim.visualMode) {\n        // Bind CodeMirror selection model to vim selection model.\n        // Mouse selections are considered visual characterwise.\n        var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n        var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n        head = offsetCursor(head, 0, headOffset);\n        anchor = offsetCursor(anchor, 0, anchorOffset);\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        updateMark(cm, vim, '<', cursorMin(head, anchor));\n        updateMark(cm, vim, '>', cursorMax(head, anchor));\n      } else if (!vim.insertMode) {\n        // Reset lastHPos if selection was modified by something outside of vim mode e.g. by mouse.\n        vim.lastHPos = cm.getCursor().ch;\n      }\n    }\n\n    /** Wrapper for special keys pressed in insert mode */\n    function InsertModeKey(keyName) {\n      this.keyName = keyName;\n    }\n\n    /**\n    * Handles raw key down events from the text area.\n    * - Should only be active in insert mode.\n    * - For recording deletes in insert mode.\n    */\n    function onKeyEventTargetKeyDown(e) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      var keyName = CodeMirror.keyName(e);\n      if (!keyName) { return; }\n      function onKeyFound() {\n        if (lastChange.maybeReset) {\n          lastChange.changes = [];\n          lastChange.maybeReset = false;\n        }\n        lastChange.changes.push(new InsertModeKey(keyName));\n        return true;\n      }\n      if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n        CodeMirror.lookupKey(keyName, 'vim-insert', onKeyFound);\n      }\n    }\n\n    /**\n     * Repeats the last edit, which includes exactly 1 command and at most 1\n     * insert. Operator and motion commands are read from lastEditInputState,\n     * while action commands are read from lastEditActionCommand.\n     *\n     * If repeatForInsert is true, then the function was called by\n     * exitInsertMode to repeat the insert mode changes the user just made. The\n     * corresponding enterInsertMode call was made with a count.\n     */\n    function repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n      var macroModeState = vimGlobalState.macroModeState;\n      macroModeState.isPlaying = true;\n      var isAction = !!vim.lastEditActionCommand;\n      var cachedInputState = vim.inputState;\n      function repeatCommand() {\n        if (isAction) {\n          commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n        } else {\n          commandDispatcher.evalInput(cm, vim);\n        }\n      }\n      function repeatInsert(repeat) {\n        if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n          // For some reason, repeat cw in desktop VIM does not repeat\n          // insert mode changes. Will conform to that behavior.\n          repeat = !vim.lastEditActionCommand ? 1 : repeat;\n          var changeObject = macroModeState.lastInsertModeChanges;\n          repeatInsertModeChanges(cm, changeObject.changes, repeat);\n        }\n      }\n      vim.inputState = vim.lastEditInputState;\n      if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n        // o and O repeat have to be interlaced with insert repeats so that the\n        // insertions appear on separate lines instead of the last line.\n        for (var i = 0; i < repeat; i++) {\n          repeatCommand();\n          repeatInsert(1);\n        }\n      } else {\n        if (!repeatForInsert) {\n          // Hack to get the cursor to end up at the right place. If I is\n          // repeated in insert mode repeat, cursor will be 1 insert\n          // change set left of where it should be.\n          repeatCommand();\n        }\n        repeatInsert(repeat);\n      }\n      vim.inputState = cachedInputState;\n      if (vim.insertMode && !repeatForInsert) {\n        // Don't exit insert mode twice. If repeatForInsert is set, then we\n        // were called by an exitInsertMode call lower on the stack.\n        exitInsertMode(cm);\n      }\n      macroModeState.isPlaying = false;\n    }\n\n    function repeatInsertModeChanges(cm, changes, repeat) {\n      function keyHandler(binding) {\n        if (typeof binding == 'string') {\n          CodeMirror.commands[binding](cm);\n        } else {\n          binding(cm);\n        }\n        return true;\n      }\n      var head = cm.getCursor('head');\n      var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;\n      if (visualBlock) {\n        // Set up block selection again for repeating the changes.\n        selectForInsert(cm, head, visualBlock + 1);\n        repeat = cm.listSelections().length;\n        cm.setCursor(head);\n      }\n      for (var i = 0; i < repeat; i++) {\n        if (visualBlock) {\n          cm.setCursor(offsetCursor(head, i, 0));\n        }\n        for (var j = 0; j < changes.length; j++) {\n          var change = changes[j];\n          if (change instanceof InsertModeKey) {\n            CodeMirror.lookupKey(change.keyName, 'vim-insert', keyHandler);\n          } else if (typeof change == \"string\") {\n            var cur = cm.getCursor();\n            cm.replaceRange(change, cur, cur);\n          } else {\n            var start = cm.getCursor();\n            var end = offsetCursor(start, 0, change[0].length);\n            cm.replaceRange(change[0], start, end);\n          }\n        }\n      }\n      if (visualBlock) {\n        cm.setCursor(offsetCursor(head, 0, 1));\n      }\n    }\n\n    resetVimGlobalState();\n    return vimApi;\n  };\n  // Initialize Vim and make it available as an API.\n  CodeMirror.Vim = Vim();\n});\n"],"sourceRoot":""}